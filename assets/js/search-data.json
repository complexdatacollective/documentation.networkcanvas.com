{"0": {
    "doc": "404 - Not found",
    "title": "The requested page could not be found.",
    "content": "This is probably because the page has been moved or deleted. We apologize for any inconvenience this has caused. Please try the following: . | Use the search function (at the top of this page) to try to locate what you are looking for. | Check your address bar for spelling mistakes or typos. | Contact the project team if you believe you are seeing this page in error, including details of the page you were trying to reach. | . ",
    "url": "/404.html#the-requested-page-could-not-be-found",
    "relUrl": "/404.html#the-requested-page-could-not-be-found"
  },"1": {
    "doc": "404 - Not found",
    "title": "404 - Not found",
    "content": " ",
    "url": "/404.html",
    "relUrl": "/404.html"
  },"2": {
    "doc": "Citing the Software",
    "title": "Other Project Publications",
    "content": "Birkett, M., Melville, J., Janulis, P., Phillips II, G., Contractor, N., &amp; Hogan, B. (2020). Network Canvas: Key decisions in the design of an interviewer assisted network data collection software suite. Social Networks. Working Paper. Hogan, B., Janulis, P., Phillips II, G., Melville, J., Mustanski, B., Contractor, N., &amp; Birkett, M. (2019). Assessing the stability of ego-centered networks over time using the digital participant-aided sociogram tool Network Canvas. Network Science. In press. Collapse . ",
    "url": "/citing-the-software/#other-project-publications",
    "relUrl": "/citing-the-software/#other-project-publications"
  },"3": {
    "doc": "Citing the Software",
    "title": "Citing the Software",
    "content": "Please cite Network Canvas in publications or presentations that are created from any research, clinical, educational, or other applicable use of the Network Canvas Suite or any of its components. Through your citation of the software, we are able to measure its impact and track the ways in which it is being used. Citing the project . When discussing the project as a whole, please cite our project website or our GitHub repositories: . Complex Data Collective. Network Canvas: Software to Simplify Complex Network Data Collection. 7 2016. https://networkcanvas.com . A BibTeX entry for LaTex users is: . @misc{network-canvas, organization = {Complex Data Collective}, title = {Network Canvas: Software to Simplify Complex Network Data Collection}, url = {https://networkcanvas.com} month = 7, year = 2016 } . URLs for citing Network Canvas repositories are: . | https://github.com/complexdatacollective/Interviewer | https://github.com/complexdatacollective/Architect | https://github.com/complexdatacollective/Server | . Current downloads for the Network Canvas Software Suite are available at: . | https://networkcanvas.com/download.html | . Citing the evaluation . You may wish to cite an evaluation of the software when discussing it in your research or grant materials. If this is the case, we recommend the following CHI paper: . Hogan, B., Melville, J., Phillips II, G., Janulis, P., Contractor, N., Mustanski, B., &amp; Birkett, M. (2016). Evaluating the Paper-to-Screen Translation of Participant-Aided Sociograms with High-Risk Participants. In Proceedings of the 2016 Conference on Human Factors in Computing (CHI ‘16). San Jose, CA. http://dx.doi.org/10.1145/2858036.2858368 A BibTeX entry for LaTex users is: . @inproceedings{inproceedings, author = {Bernie Hogan and Joshua Melville and Gregory Phillips II and Patrick Janulis and Noshir Contractor and Brian Mustanski and Michelle Birkett}, year = {2016}, month = {05}, pages = {}, title = {Evaluating the Paper-to-Screen Translation of Participant-Aided Sociograms with High-Risk Participants}, volume = {2016}, journal = {Proceedings of the SIGCHI conference on human factors in computing systems . CHI Conference}, doi = {10.1145/2858036.2858368} } . ",
    "url": "/citing-the-software/",
    "relUrl": "/citing-the-software/"
  },"4": {
    "doc": "Frequently Asked Questions",
    "title": "Frequently Asked Questions",
    "content": " ",
    "url": "/faq/",
    "relUrl": "/faq/"
  },"5": {
    "doc": "Home",
    "title": "Project Documentation",
    "content": "A home for tutorials, guides, and project information about the Network Canvas project.{: .fs-6 .fw-300 } . Project Overview Installation Guide Download Software . Welcome to our documentation portal, and thank you for your interest in the Network Canvas project. Producing documentation is a top priority for our team, but it will take us some time to cover everything. If you spot a gap in our documentation, or have a question, please feel free to contact us. In the meantime, thank you for your patience! . ",
    "url": "/#project-documentation",
    "relUrl": "/#project-documentation"
  },"6": {
    "doc": "Home",
    "title": "Getting Stared",
    "content": "To get started using the Network Canvas tools, read the project overview, and download the latest versions of the software. We then suggest you explore the tutorial section, beginning with using Interviewer. We encourage you to use the search function at the top of each page to find articles on any given topic. Our pages are heavily interlinked, and information is necessarily spread around. ",
    "url": "/#getting-stared",
    "relUrl": "/#getting-stared"
  },"7": {
    "doc": "Home",
    "title": "Site Structure",
    "content": "Please explore the pages and headings to the left. Aside from some top-level pages (such as the Project Overview and the Installation Guide), the bulk of our documentation is under the following headings: . | Tutorials - where you will find in-depth articles that take you through the most fundamental tasks you can accomplish with the software, such as building a protocol, running it in Interviewer, and exporting data. | How-To Guides - this section contains short guides on how to complete common tasks using all three apps. | Interface Documentation - if you are looking for specific information about the configuration options of an interface, this section contains a page dedicated to each type. | Key Concepts - which has self-contained articles on all the fundamental concepts within the Network Canvas software. | Technical Reference - this section contains reference pages on the design of the software, our security model, and best practices. It also contains information for developers looking to contribute features. | . ",
    "url": "/#site-structure",
    "relUrl": "/#site-structure"
  },"8": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    "relUrl": "/"
  },"9": {
    "doc": "Installation Guide",
    "title": "Which applications do I need?",
    "content": "Each application of the Network Canvas Suite can be downloaded and installed individually. You do not need to install all applications to use the software. | Install Interviewer on any device you will use to interview participants. It runs your Network Canvas protocols and collects data in the field. | Install Architect on a desktop computer that you will to use to design your Network Canvas interview protocol. | (Optionally) Install Server if you wish to use it as a central data storage system, or as a means to deploy interview protocols to your devices. See “do I need Server” (below) for further information. | . Do I need Server? . Server has been designed specifically for scenarios where a dedicated team member will be responsible for managing data. This team member should be prepared to work with their IT department, or else have good knowledge of computer networking principles, in order to configure Server to send and receive data securely. Smaller studies, or extremely large studies, may benefit from working directly with data exported from Interviewer. For more information, see our tutorial on offline data management workflows. ",
    "url": "/installation-guide/#which-applications-do-i-need",
    "relUrl": "/installation-guide/#which-applications-do-i-need"
  },"10": {
    "doc": "Installation Guide",
    "title": "System Requirements",
    "content": "All three applications are supported only when running on Windows 10 (1909) or newer, macOS 10.15.4 or newer, Android 10 or newer, and iPadOS 14.2 or newer. For desktop applications, we recommend a modern device, featuring a high resolution screen (greater than 900 pixels effective vertical resolution), ample RAM, and dedicated graphics. Performance may differ considerably depending on the power of the device that you use, and you should be aware that this can negatively impact the interview experience for your research participants, leading to poorer quality data. You may install and run the software on devices that do not meet these criteria, but we are unfortunately unable to offer support regarding technical issues if you do. ",
    "url": "/installation-guide/#system-requirements",
    "relUrl": "/installation-guide/#system-requirements"
  },"11": {
    "doc": "Installation Guide",
    "title": "Windows",
    "content": "Visit the download page, and download the Windows version of each app you require. Open each .exe file. You may be presented with a dialog that says the application cannot be run because it is from an unsigned publisher. This happens because our apps have not yet built up enough trust with Microsoft to automatically pass these filters. This will change as more users install our apps. In order to continue to install the application simply click the “more info” text in the dialog. Then a “Run Anyway” button should appear. Once the application is installed it should open straight away. You should also be able to find the application in your program list from the start menu. ",
    "url": "/installation-guide/#windows",
    "relUrl": "/installation-guide/#windows"
  },"12": {
    "doc": "Installation Guide",
    "title": "macOS",
    "content": "Visit the download page, and download the macOS version of each app you require. These are packaged in the form of a DMG disk archive. When you double-click on the DMG file it will open a new Finder window with the application icon and a folder representing your computer’s “Applications” folder. Drag each application into the Applications folder. If you are prompted for authentication and you do not have it, you can simply drag the application to anywhere underneath your home directory. Once the application is installed you will need to double click on the application icon to open the program. ",
    "url": "/installation-guide/#macos",
    "relUrl": "/installation-guide/#macos"
  },"13": {
    "doc": "Installation Guide",
    "title": "Linux",
    "content": "We provide Linux packages in a variety of formats, and for both x86 and ARM architectures. Visit the download page, and click on the link for downloading the apps you need on Linux. You will be redirected to the most recent release on GitHub, where you will find the package files themselves. Please refer to your distribution’s documentation on which package formats are supported, and for specific installation instructions. If you have difficulties installing or running these packages, please contact the project team. Please note that we no longer support the SNAP package format, owing to difficulties with the build process. If you are using earlier versions of the software that were distributed in this format, please update to one of the currently supported packages. ",
    "url": "/installation-guide/#linux",
    "relUrl": "/installation-guide/#linux"
  },"14": {
    "doc": "Installation Guide",
    "title": "Android",
    "content": "Installation on Android devices works the same as with any other Android app. It can be found by opening the Play Store app, and searching for “Network Canvas Interviewer”. Alternatively, you can visit the Play Store website, and initialize the installation on your devices from there. Please note that Interviewer requires Android version 10 or newer, and will work best with larger tablet devices (9.7”+). Installation is restricted to devices that meet these criteria. If you cannot find Interviewer in the Play Store, it is likely because your device is not compatible. If you believe your device should be compatible and you still cannot find the app in the Play Store, please contact us. ",
    "url": "/installation-guide/#android",
    "relUrl": "/installation-guide/#android"
  },"15": {
    "doc": "Installation Guide",
    "title": "ChromeOS",
    "content": "If your ChromeOS device supports installing Android apps, you can install the Interviewer app as usual through the Google Play Store. To do this, please see the instructions above for installing the app on Android. Please note that only Interviewer is specifically designed to work with ChromeOS, and only when run as an Android app. Running Interviewer, Architect or Server through Linux app compatibility is not supported at present. ",
    "url": "/installation-guide/#chromeos",
    "relUrl": "/installation-guide/#chromeos"
  },"16": {
    "doc": "Installation Guide",
    "title": "iOS",
    "content": "Interviewer is available from the Apple App Store, searchable as “Network Canvas Interviewer”. Interviewer was developed on a 12.9” iPad pro, and will work best with larger iOS devices (9.7”+). ",
    "url": "/installation-guide/#ios",
    "relUrl": "/installation-guide/#ios"
  },"17": {
    "doc": "Installation Guide",
    "title": "Installation Guide",
    "content": " ",
    "url": "/installation-guide/",
    "relUrl": "/installation-guide/"
  },"18": {
    "doc": "Project Overview",
    "title": "Three Applications",
    "content": "The Suite consists of three applications: . | Architect - A tool for building Network Canvas interview protocols | Interviewer - An tool that loads and administers interview protocols to study participants | Server - A tool for researchers to manage their data and coordinate the survey deployment process | . These three applications work together to provide a seamless end-to-end workflow up to the point of analysis. Which applications do I need? . Although the Network Canvas software is designed to provide a complete end-to-end workflow when used together, you do not need to use all elements of the suite in all circumstances. In particular, smaller studies may find that they do not need to use the Server application, since it mostly benefits scenarios where large numbers of field devices running Interviewer must be managed by a single tech-savvy member of your team. If this is not a requirement for your study, you can choose instead to export data directly from Interviewer (see our tutorial on offline data management workflows for more on this). If you choose not to use Server you will also need to consider the logistics of loading your interview protocol onto your field device. This is discussed in our tutorial article on using Interviewer. ",
    "url": "/project-overview/#three-applications",
    "relUrl": "/project-overview/#three-applications"
  },"19": {
    "doc": "Project Overview",
    "title": "Design Principles",
    "content": "Before we go into any further specifics, we will next describe a few of the core design principles that underlie the Software. Ontological Flexibility . Social networks are not a singular methodology, but a broad approach to research which straddles multiple disciplines and research ontologies. Therefore, we have focused on creating a flexible suite of tools which have few constraints on the type of study that can be developed. Researchers construct their own protocols - customized to their own needs. And protocols are built within Architect, by selecting from a number of Interfaces which we’ve designed to be optimized for the collection of specific types of data. Each Interface is also able to be customized. Furthermore, both nodes and edges are able to be generated in multiple ways. For researchers utilizing rosters, interviewees are able to select their alters from pre-loaded lists, or type into text fields which search and filter. For researchers not utilizing rosters, researchers have two options: an ultra quick name generation interface for when only a name is required to be captured, or a Name Generator which uses per-alter forms to capture detailed attributes. Our tool also allows the capture of multiple relationships between entities, and while these might be people, they may be places visited, events attended, or relationships with particular medical providers. In-person and Interviewer-assisted . Our tool requires that interviews occur in the presence of an interviewer, on an interviewer-controlled machine, as we found that both remote interviews and interviews conducted on participant devices were too difficult to ensure appropriate privacy and quality of user experience. Therefore, interviewers are expected to pre-install the Network Canvas App on study devices, as well as pre-load the appropriate interview protocol, and finally, assist with the transfer of data to the server after the interview. However, we have found that the level of engagement during the actual interview is able to vary quite a bit depending on the level of complexity of the protocol. An interviewer-assisted interview Visualization . Network Canvas prioritizes good visual design and intuitive touch interactions. Our focus on the design and feel of the tools sets us apart from other survey tools - and academic softwares, in general - we also believe our focus on quality design helps make abstract concepts more tangible to participants and researchers. An interview running on an iPad Pro End-to-end Workflow . We’ve created an end-to-end workflow with the aim of lowering costs (both material and technical) for network researchers. We also believe this will increase the potential for reproducibility across network studies. Open-Source Development . Key in sustaining this Software Suite is input and collaboration with the community. Therefore, all development is open-source. We established a not for profit entity (The Complex Data Collective - or CODACO) which owns all IP and copyright associated with the project. This entity then grants a license to any user of the software under something called the General Public License. You may have heard of it (it is popular in open source software) but it provides anyone who wants to use our software certain guaranteed freedoms. | Freedom to use the software commercially, without restriction | Freedom to modify the software however they see fit | Freedom to distribute the software | . These freedoms are protected by some requirements built into the GPL license: . | Any modifications must be made available under the GPL license | You must include a copy of the original source code with any versions you distribute, making it possible for others to modify | . We have guidelines on managing contributions and collaborations to the project that we will be happy to discuss later if that interests you. We believe the fact that this is an open source software that is “owned” by a not for profit entity means that it should be possible to make extending it compatible with the policies of grant awarding bodies. ",
    "url": "/project-overview/#design-principles",
    "relUrl": "/project-overview/#design-principles"
  },"20": {
    "doc": "Project Overview",
    "title": "Project Overview",
    "content": "The Network Canvas Software Suite is different from many existing survey tools, most of which have been optimized for capturing individual rather than network data. Our tool captures data about both the individual and their social network through intuitive and engaging touch-optimized interfaces. By visually representing people, places, and concepts as nodes alongside relationships between the nodes and attributes of nodes and relationships, Network Canvas can make seemingly complex data more manageable and intuitive in an interview setting. To provide an overview of the project, including background information about our team, our aims and objectives, and the functionality of the software, we have created the following promotional video. ",
    "url": "/project-overview/",
    "relUrl": "/project-overview/"
  },"21": {
    "doc": "Protocol Gallery",
    "title": "Protocol Gallery",
    "content": " ",
    "url": "/protocol-gallery/",
    "relUrl": "/protocol-gallery/"
  },"22": {
    "doc": "Building a protocol using Architect",
    "title": "What is Architect?",
    "content": "Architect is a desktop application which runs on Windows, macOS, and Linux operating systems. The purpose of Architect is to provide a simple means for researchers to build Network Canvas interview protocols, without needing extensive technical knowledge. It aims to provide a visual and intuitive user interface, so that you can focus on the content of your interviews. You don’t need to run Architect on the computer that you use to run Interviewer or Server, but you can if you wish. ",
    "url": "/tutorials/building-a-protocol/#what-is-architect",
    "relUrl": "/tutorials/building-a-protocol/#what-is-architect"
  },"23": {
    "doc": "Building a protocol using Architect",
    "title": "Opening Architect",
    "content": "The Architect start screen Upon opening Architect, you are greeted by the start screen. Like the start screen in Interviewer, you will see a welcome panel that contains links to the project overview video and the documentation website, with other sections becoming available as needed. When opened for the first time, the Architect start screen presents two task options: (1) create a blank new protocol, or (2) open an existing protocol from your computer. In this tutorial we will be building a protocol from scratch, so we are going to start by creating a blank protocol. Click the “Create New Protocol” button within the tasks panel. Save the file with a name and location that you will be able to find later. Network Canvas protocols are stored in a file with the extension .netcanvas.They are just like any other files on your computer, meaning you can move them around, rename them (more about this later), and you can (and should!) back them up. The .netcanvas file contains all of the data in your protocol. So if you use roster data, images, or video, these will be embedded within the file. ",
    "url": "/tutorials/building-a-protocol/#opening-architect",
    "relUrl": "/tutorials/building-a-protocol/#opening-architect"
  },"24": {
    "doc": "Building a protocol using Architect",
    "title": "The protocol overview screen",
    "content": "Once you have created or opened a protocol, you will be taken to the protocol overview screen. This screen is designed around the vertical “timeline” metaphor also used by Interviewer. It visually represents the stages of your interview in the sequence that your participants will see them. The panel at the top is the protocol card that you will see when you import this protocol into Server or Interviewer. It shows the protocol name and description, and has two buttons for accessing the protocol’s resource library and managing the codebook (these areas are discussed later). The protocol description is optional. Whatever you enter will show up in the Interviewer App on the start screen, and when browsing the list of available protocols from Server. In the bottom left, you can see the “Return to Start Screen” button. Clicking this button will take you out of the current protocol, and back to the start screen. Since we have just created a new protocol, we have a single button at the bottom of the screen, which enables us to add our first stage. ",
    "url": "/tutorials/building-a-protocol/#the-protocol-overview-screen",
    "relUrl": "/tutorials/building-a-protocol/#the-protocol-overview-screen"
  },"25": {
    "doc": "Building a protocol using Architect",
    "title": "Adding a stage",
    "content": "We are going to begin by configuring an Information Interface. Click the add new stage button. You will see a screen that provides a menu of all available Interfaces within the app. Interfaces are grouped together by type, with the example below showing all available name generators. Each Interface is designed for a specific task within a network interview. For now, scroll down and select the “Information” Interface from the “Utilities” section. Selecting an Interface will open the stage editor, which is where the configuration of the Interface takes place. Setting the Stage Name . All stages have a name, which is shown next to the stage icon in the timeline and lets you quickly differentiate between stages of the same type. We will call our stage “Welcome”, so enter this text under “Stage Name”. When creating your own protocols, we encourage you to use a system for naming your stages. Page Heading . The page heading allows you to customize a large title element that will show at the top of your Information Interface. Here we will give the heading, “Welcome to the Sample Protocol.” Next, we will add the information we want displayed on the screen. Edit Items . The Edit Items panel allows you to add various types of media you would like included on the screen. You have the option to add image, video, audio, or text content. Each resource used will be displayed in vertical blocks according to the order you add them. Content blocks can also be reordered by dragging. To add a resource to this screen, click the ‘add new item’ button at the bottom of the panel. A new screen will open where you can choose between the media types available. Text content can be added directly in markdown. Image, audio, and video files can be added by selecting the type and browsing for the file to add, either from a location on your device or from the resource library (if you have added content there). As in the previous Interviewer session, we will not go through the configuration of each Information Interface included in the sample protocol here. As a reminder, Information Interfaces can be used as frequently as you like throughout your protocol to help describe an upcoming task, orient a participant to a series of prompts, or present participants with a resource to consider. Once we have added all resources that we want to include on this stage, we click the “Save and Return” button in the bottom right. This action saves our stage and returns us to the timeline view where our newly configured stage is now visible. ",
    "url": "/tutorials/building-a-protocol/#adding-a-stage",
    "relUrl": "/tutorials/building-a-protocol/#adding-a-stage"
  },"26": {
    "doc": "Building a protocol using Architect",
    "title": "Creating Name Generators",
    "content": "We will now create three separate name generator stages, which appear as stages 4, 6, and 8 in the sample protocol. The first one uses a “quick add” name generator, followed by one that utilizes a “side panel”, and finally a name generator that uses forms. ",
    "url": "/tutorials/building-a-protocol/#creating-name-generators",
    "relUrl": "/tutorials/building-a-protocol/#creating-name-generators"
  },"27": {
    "doc": "Building a protocol using Architect",
    "title": "Name Generator using Quick Add",
    "content": "First, within the timeline view, we click the add a stage button. From the interface menu, we select the “Name Generator (using quick add).” When the new stage opens, we define a stage name as we did for the previous stage. Creating a New Node Type . Before we can continue, we must tell Architect which type of node this interface will create. Since this is our first name generator, we have no node types defined yet. Click the “Create New Node Type” button to begin the process of creating one. Part of the ontological flexibility of the Network Canvas suite is the ability to model unlimited numbers of node and edge types. These types are top level categories that differentiate nodes and edges from one-another. Common node types might include “person”, “place”, or “organization”, but these categories are entirely up to you to decide upon. Our name generator will ask about people, so we will name our node type “Person”. We can select a color to differentiate this node type from others, though in this case we will leave the default coral color selected. Finally we will select the person icon to use for this node type. This icon is shown in Interviewer wherever the participant has the opportunity to create a new node of this type. Click “Save and Return” to create the node type, and return to the name generator edit screen. Creating a Quick Add Variable . Next, we need to create a quick add variable that will be used to store data enter for each alter nominated by the participant. Unless you have a good reason not to, this variable should be called “name”. Interviewer will use this variable as the label for every node created on this stage. To create a new variable, select the dropdown menu and click “create new” and type the name of your variable (e.g., “name”). Click the “Create” button and you will see the new variable name selected as the quick add variable. Creating Prompts . Next we must provide some questions to prompt the participant into adding alters within the interview. Most stages use the concept of “prompts” to allow you to define questions to put to the participant during the interview. You are free to explain the task to the participant in ways that are meaningful to your study. You can have multiple prompts on a single stage, or a single prompt per stage - the choice is yours. You may wish to think about grouping prompts by theme, and then having one stage for each theme. For example, a “Name Generator (family)” stage could contain prompts about family alters, and “Name Generator (colleagues)” could contain prompts about professional alters. Prompts can contain formatting such as bold or italicized text to create emphasis and rhythm. To create this formatting, use markdown syntax. Click the “Create New” button in the prompt section, to open the new prompt edit form. Our first prompt will ask the participant to name the people with whom they have felt close to or discussed important matters. Enter the text “Within the past 6 months, who have you felt close to, or discussed important personal matters with?”, and click “Save and Close”. Preview Mode . We can now take the opportunity to see what our stage will look like in our finished interview by using the “Preview” feature. Clicking it will open a window with the current stage loaded, and show the interface functioning as it will in Interviewer on a study device. Preview mode is designed to let you understand how your stage will be presented to your participants, taking into account the device that you will be using. You can choose between different device presets, to mimic the look of a specific piece of hardware (for example you can emulate the screen size of an iPad, or a widescreen laptop). If the window becomes too large, you can scale it so that you can fit it within your workspace. It is important to note that although you can enter data in preview mode - for example by creating nodes - the data does not persist after you close the window! . Click the pink “Preview” button in the bottom left hand corner of the stage editor, and the preview window will open. We can then click “Save and Return” on the stage editor to return to our timeline view, but now with our new stage visible. ",
    "url": "/tutorials/building-a-protocol/#name-generator-using-quick-add",
    "relUrl": "/tutorials/building-a-protocol/#name-generator-using-quick-add"
  },"28": {
    "doc": "Building a protocol using Architect",
    "title": "Quick Add with a Side Panel",
    "content": "Next, we are going to configure another Name Generator (using quick add) interface, only this time we will include a side panel. First, we will create a stage name, select the person node type (which we previously created), assign the quick add variable of “name”, and create a new prompt. The prompt for this stage will be, “Within the past 6 months, who have you discussed social networks research with?” . Now, we will add the side panel. Click the “Add New Panel” and give the panel the title “People you have previously mentioned.” This title will appear across the top of the side panel and will contextualize the nodes that appear to the participant. Next, we need to choose a data source for this side panel. We have two options: either we use the network constructed during the interview or we bring in an external data file (e.g., a roster) that will populate within the side panel. In this example, we will choose to use the network from the in-progress interview. You can optionally preview the interface at this point, checking that the prompts and the form look and function as you expected. When you are satisfied, click continue to add your stage. At any point during this tutorial, free free to click the \"Save Changes\" button in the bottom bar when on the timeline view, or select \"File -&gt; Save\" from the menu. ",
    "url": "/tutorials/building-a-protocol/#quick-add-with-a-side-panel",
    "relUrl": "/tutorials/building-a-protocol/#quick-add-with-a-side-panel"
  },"29": {
    "doc": "Building a protocol using Architect",
    "title": "Name Generator using Forms",
    "content": "We will now create a new name generator stage that uses a form to capture data on alters named. As before, we add a new stage (selecting the Name Generator (using forms) from the interface menu) and add a stage name. Next we will create a new node type for “Clinic” on this stage as we will be asking a prompt about clinics rather than people. Once we create the node type for Clinic, we move on to edit the form. Form . This section is where we will define the fields that will be shown on the form when the participant creates a node on this name generator. Fields capture data about alters or ego, and are where specific variables are defined. First, let’s start with creating a title for the form to orient the participant to the information we want to collect. Enter the title “Add a Clinic or Health Care Provider.” . Next, we will define the fields of the form. By clicking “Create New” in the fields panel, a new screen opens which asks us to define a variable for the field, the question prompt, an input control, and to select any validation we may want to include. For the first field, we want to know the name of the clinic the participant is nominating so we use the variable “name” that we previously created by selecting it from the drop down menu. Next, we will enter the text for this field label and in our example we will use a question prompt, “What is the name of this clinic?” . | Key Concept: Creating vs selecting variables | . | Many screens in Architect allow you to either create a new variable, or select an existing variable. If this is the case, the text next to the input will usually tell you.When you want to create a new variable, click the box and select “Create New” from the drop down menu.Otherwise, click an existing variable from the list in the drop down menu. | . Finally, we choose the input control that will be shown to collect this variable. | Key Concept: Input controls | . | Architect and Interviewer implement many different types of input control [text, number, checkbox group, toggle, radio button group, toggle button group, date picker, likert scale, visual analog scale].This is because the most appropriate interface for assigning a variable depends very much on the specific nature of the variable, and not just on its data type. For example, when collecting an ordinal variable that represents a likert scale, you might prefer a range slider OR a group of radio buttons. | . Because we are asking for the name of the clinic - a simple text variable - a text input is the most appropriate option. Finally, we can define our validation requirements – if any – for this field. We will indicate that this text field is required. The validation options available vary depending on the type of variable. By adding a validation of required, the participant will necessarily include information in this field before they can proceed. Click “Save and Close”, and we have created our first form field. Now, using the process we learned above, we will create the two additional fields for this form. Create the following fields, with appropriate input controls, question prompts and options: . | A last_visit variable, using the DatePicker input control, prompt of “When was your visit?”, and an appropriate start range | A visit_purpose variable, using the Text Area input control, and a prompt of “In your own words, what was the purpose of your visit?” | . After completing the form, we will configure the prompt for the stage. Click “Create New” in the prompts section, and enter the text, “Within the past 12 months, which clinics or healthcare providers have you visited?” . ",
    "url": "/tutorials/building-a-protocol/#name-generator-using-forms",
    "relUrl": "/tutorials/building-a-protocol/#name-generator-using-forms"
  },"30": {
    "doc": "Building a protocol using Architect",
    "title": "Small Roster Name Generator",
    "content": "Next we will develop a name generator that uses a small roster brought in as an external data file. Small rosters, by our definition, are datasets containing up to 100 nodes. As we did in prior name generators above, we will first select the interface we want to configure (Small Roster Name Generator), add a stage name, and create a new node type for “Classmate”. Next we will select the external data source to bring into the protocol that will populate the nodes on the roster. For this example, we have used a fictitious classroom roster. To use the same roster as the sample protocol, please click here to download our CSV file. Alternatively, use any other roster you have on hand. Just as you added resources to the Information Interface above, you will also browse for your external data source from the protocol resource library if you saved it there or else from another location on your device. We will then define what display properties are used to identify the nodes in the roster as they appear to the participant. First we select the variable that is defined in the external data file - in this case “first_name.” Next, we define how we want that variable to appear to the participant on the roster - in this example we enter “First Name.” We repeat the same process for the last_name variable. We can optionally choose to include sorting controls. Sorting controls are especially useful when a roster is large enough to make discoverability difficult at first glance. In this example, we choose to implement an initial sort order that uses the “first_name” variable to order the roster cards in an ascending order. Refer to our Interface Documentation for more in depth instruction, including useful Do’s and Don’ts of working with roster data. Last, we implement a prompt for the stage, following the same process we did in the previous stages. We enter the prompt that includes instructions for how to nominate a node from the roster, “Please select any members of your degree class that you spend time with other than when studying. Tap a card to select, and press the down arrow when you are finished.” . ",
    "url": "/tutorials/building-a-protocol/#small-roster-name-generator",
    "relUrl": "/tutorials/building-a-protocol/#small-roster-name-generator"
  },"31": {
    "doc": "Building a protocol using Architect",
    "title": "Large Roster Name Generator",
    "content": "By our definition, large rosters are datasets with more than 100 nodes. Following the example from the prior stage, we will first select the interface we want to configure (Large Roster Name Generator), add a stage name, and create a new node type, this time for “University”. Again, we will pull in a data source we plan to use to populate our roster. In our example, we use a large CSV that includes universities around the world. Click here to download it. By default, the roster cards will use the “name” attribute from your external data file as the main card title. In this example, we choose to also include “website” as an attribute to display. Next, we will configure how the roster file is searchable to the participant. The functionality available for this interface includes the ability for participants to search the database for specific attributes in order to locate the alters they want to select. The search options listed will depend on the variables outlined in your datafile. Here, we have the option to select “country”, “name”, and “website”, and we choose to include all three. We can also narrow down the options that appear to a participant when they search on the stage by selecting “Exact” or “High Accuracy.” In this case, we select “High Accuracy.” . Finally, we add a prompt to this stage, “Which universities have you either visited or studied at?” Then, we click “Save and Return” to save the stage and navigate back to the timeline view. ",
    "url": "/tutorials/building-a-protocol/#large-roster-name-generator",
    "relUrl": "/tutorials/building-a-protocol/#large-roster-name-generator"
  },"32": {
    "doc": "Building a protocol using Architect",
    "title": "Creating an Ego Form",
    "content": "The next stage in this sample protocol uses the Ego Form Interface. We create the Ego Form and set a stage name as we have previous interfaces. Introduction Panel . The introduction panel is a feature of the Ego Form Interface that lets you introduce the form to the participant. You might use it to explain which data you are asking for, and why. In our case, we explain the intended use of the Ego Form Interface. Now, let’s create a series of fields for our ego form just as we did while configuring the Name Generator using forms. If you don’t remember how we did this, please review above. Next, we will create the following fields with associated variables, question prompts, input controls, validations (if used): . | first_name, “What is your first name?”, Text Area, Required validation | last_name, “What is your last name?”, Text Area, Required validation | dob, “What is your date of birth?”, DatePicker with end range 2002/January/1 | languages_spoken, “Which of the following languages do you speak fluently?”, Toggle Button Group with options English, Mandarin Chinese, Hindi, Spanish, French, Arabic, Bengali, and Russian | existing_software, “Overall, how satisfied are you with existing social network analysis software?”, Radio Group with options Very Satisfied, Somewhat Satisfied, Neither Satisfied nor Dissatisfied, Somewhat Dissatisfied, and Very Dissatisfied | research_support, “How satisfied are you with the level of support you receive?”, Likert Scale with Very Satisfied, Somewhat Satisfied, Neither Satisfied nor Dissatisfied, Somewhat Dissatisfied, and Very Dissatisfied | operation_pain, “Thinking back to your last medical procedure, how much pain do you feel you experienced?”, Visual Analog Scale with min and max labels as No Pain and Unbearable Pain | prefered_contact_method, “How would you prefer to be contacted about your next interview?”, Checkbox Group with options Email, Post, SMS, and Phone Call | other_info, “Is there any other information you would like to provide at this time?”, Text Area | . To demonstrate the range of input control options, we implemented far more fields than are likely to be best practice for a form within an interview. You can learn more about input controls here . We click “Save and Return” and go back to the timeline view to implement the next stage. ",
    "url": "/tutorials/building-a-protocol/#creating-an-ego-form",
    "relUrl": "/tutorials/building-a-protocol/#creating-an-ego-form"
  },"33": {
    "doc": "Building a protocol using Architect",
    "title": "Creating a Per Alter Form",
    "content": "Let’s next repeat that process, but this time creating a form that will capture data from alters on the Per Alter Form Interface. Create a new stage using the Per Alter Form Interface and set the stage name. Next, select the node type “University” and scroll down to configure the Information Panel. We will now add just two fields to this form. Here are the details you need, following the same process as above: . | Variable called visit_or_study, prompt of “Did you visit this university, or study there?”, input control of “Radio Group” with options “Visited” and “Studied”, “Required” validation | Variable called overall_review, prompt of “Overall, how would you describe your experience at this university?”, input control of “Likert Scale” with options “Excellent”, “Above Average”, “Average”, “Below Average”, “Poor” | . As before, save when you are finished, and return to the overview screen of your protocol. ",
    "url": "/tutorials/building-a-protocol/#creating-a-per-alter-form",
    "relUrl": "/tutorials/building-a-protocol/#creating-a-per-alter-form"
  },"34": {
    "doc": "Building a protocol using Architect",
    "title": "Creating Sociograms",
    "content": "For the next stage, we use the Sociogram Interface. Create the stage, set a stage name, and select the “Person” node type. Node Positioning . Next we need to choose a background image for the Sociogram. We can decide between using a default concentric circles background or adding our own image file from the resource library or from another location on our device. For this first example, we will choose the default option and specify that we want 3 circles skewed so that the middle is proportionally larger. We will add a prompt for the stage that reads, “Please position the people you have named amongst the concentric circles. Place people who know each other together, and put people you are closer to towards the center of the circles.” . You will see that when creating a prompt on the Sociogram, you have the option of defining a layout variable. The layout variable will be used to store the X/Y coordinates of the nodes when the participant positions them on the screen. If you have multiple prompts on your Sociogram, you may wish to use the same variable layout for each (which will keep the nodes positioned as they originally are by the participant) or you may wish to create a new layout variable for each prompt (which would require the participant to reposition the nodes each time). In this example, we will create a “sociogram_layout” variable for this stage. We finish by clicking “Save and Close” to close the prompt editor, then “Save and Return” to save the stage. ",
    "url": "/tutorials/building-a-protocol/#creating-sociograms",
    "relUrl": "/tutorials/building-a-protocol/#creating-sociograms"
  },"35": {
    "doc": "Building a protocol using Architect",
    "title": "Background Images",
    "content": "Now we’ll configure another Sociogram, but this time we’ll bring in an image asset to serve as the background. Follow all the previous steps, but now choose an image as the background type instead of using the concentric circles. If you have an image file saved to your resource library you can browse for it, otherwise you can add an image file saved elsewhere on your device. In this case, we designed a quadrant image where we will ask the participant to drag their alters based on the context of the relationship. You should think carefully about how the choices you make regarding the background will impact the way your participants position their nodes. As before, we will enter a prompt and not assign a task for the stage. The prompt text is, “Please position the people you have named in the boxes according to which group you feel they most belong to.” We save the stage and move on to the next. The Sociogram is an interface designed to allow participants to interact with the alters produced within Name Generator stages in three principle ways.(1) Layout, where the participant spatially arranges the nodes; (2) Edge creation, where the participant can create alter-alter ties; (3) Variable toggling, where the participant can nominate alters has having a given boolean attribute. ",
    "url": "/tutorials/building-a-protocol/#background-images",
    "relUrl": "/tutorials/building-a-protocol/#background-images"
  },"36": {
    "doc": "Building a protocol using Architect",
    "title": "Edge Creation",
    "content": "We will create another Sociogram stage to experiment with creating edges. For this stage we’ll use node type “Person” and the concentric circles background with 3 circles skewed. We create our first prompt, “Please connect any two people who might spend time together without you being there” and we use the sociogram_layout variable we already created. Now we will enable edge creation on a Sociogram prompt, by toggling the switch “create edges by tapping on a node” option, in the “Edge Display and Creation” section. In the next box, we will either create a new edge type or select an existing one. Since we have not yet created any edge types, we will define one as “know” to correspond with the prompt. We click “Save and Close” to return to the Sociogram editor. Next, we add another prompt, “Please connect any two people who have conflict, or who don’t get on well with each other” and use the same sociogram_layout variable. We also choose edge creation as the task for the stage, but create a new edge type of “conflict” as we will now be capturing alter-alter ties that are conflictual. The sociogram is the primary location within the interview where edges are created.A sociogram prompt can only create a single edge type at a time, but note that it can display several.In the scenario where multiple edge types are selected for display, creating a new edge that would cover an existing one works simply - the existing edge is visually replaced with the new edge type. Both edges are still stored in the interview network. Removing this new edge will revert the visual display to the previously visible edge type (only one edge type can be created or removed on a prompt).You may consider using this feature to progressively build up a network, by allowing the participant to use the visual “scaffolding” of existing edges to quickly identify where to create new ones. ",
    "url": "/tutorials/building-a-protocol/#edge-creation",
    "relUrl": "/tutorials/building-a-protocol/#edge-creation"
  },"37": {
    "doc": "Building a protocol using Architect",
    "title": "Implementing the Dyad Census",
    "content": "By now you should have a feel for the process of configuring a stage within Architect. We will continue by adding a Dyad Census Interface stage to our interview, which builds on many of the concepts we have already covered. From the timeline overview, click the “Add New Stage” button, and select the Dyad Census interface. Again, we name the stage and this time we select node type “Classmates.” . We will next implement skip logic so that the stage will only show for participants who nominate at least two classmates on the small roster name generator implemented previously. We do this by toggling the switch to enable skip logic for the stage, selecting “Skip this stage if”, and, then, defining an alter rule by clicking the “Add Alter Rule” button to define the equation. We define the rule by selecting the alter node type of “Classmate”, then selecting rule type of “Presence”, and, finally, selecting “Does not Exist.” . As on other name interpreter interfaces, we will also configure the Introduction Panel and define a prompt. For this stage, we enter the prompt, “To the best of your knowledge, do these two people spend time together outside of class?” We previously created two edge types on the sociogram which appear available for our use on this prompt. We will select the “know” edge type since we are asking the participant whether any two classmates know one another. Toggling a Variable . In our final Sociogram stage in this protocol, we will implement variable toggling - or the action that allows a participant to toggle a boolean variable to “true” or “false” by tapping a note. Once again, we create the stage, set the stage name, select the “Person” node type, and use the concentric circle background with 3 circles skewed. Next, we create a new prompt, with the text, “Please select anyone who you have asked for advice within the previous 6 months”. Re-use the layout variable (“sociogram_layout”) we created previously. We do not want to enable edge creation on this prompt, as it would disable the variable toggling function (the two modes are mutually exclusive). However, we can still display edges in order to help the participant locate nodes. To do this, select “Know” and “Conflict” under “Display edges of the following type(s)”. Configuring the sociogram prompt to enable variable toggling involves two steps: (1) toggle “Enable variable toggling by tapping a node” to the “on” position, and (2) create (or select) a boolean variable to be assigned in the box that appears below. In this case of this prompt, using the techniques we have already covered, create a variable called “provides_advice” and press “Save and Close”. We will now complete the exact same steps for the second prompt, which reads, “Please select anyone who has supported you financially within the previous 6 months.” This time, we will create a boolean variable of “provides_material_support.” . We have now finished configuring this sociogram stage. When previewing a stage using an interface type that does not create nodes, you may notice that no nodes are available to test the stage’s functionality.To address this, the preview mode allows you to create nodes from any earlier stages in your interview that are capable of this (primarily name generators or roster interfaces).Simply navigate to a stage that creates nodes from within preview mode, create some nodes suitable for your sociogram stage, and then navigate to the sociogram stage - your nodes will appear, and you will be able to test edge creation, variable toggling, and positioning. ",
    "url": "/tutorials/building-a-protocol/#implementing-the-dyad-census",
    "relUrl": "/tutorials/building-a-protocol/#implementing-the-dyad-census"
  },"38": {
    "doc": "Building a protocol using Architect",
    "title": "Creating an Ordinal Bin",
    "content": "We now wish to create an Ordinal Bin interface so that we can quickly and efficiently ask our participant about the frequency of contact they have with each alter. From the timeline overview, add a new stage using the Ordinal Bin interface. As with previous interfaces, begin with naming the stage (“Contact Frequency”), and selecting our node type (“Person”). Most of the configuration for this interface happens within the prompt. Create a new prompt, and enter the text, “When was the last time that you communicated with each of the people you named?”. Next, we need to create an ordinal variable. This is fundamentally the same process that we carried out when configuring the language variable in our ego form. Every time we create an ordinal or categorical variable within Architect, we will enter a label and a value. The value is what will be stored in our dataset. Both text and numerical values are allowed. Complete the labels and values as in the screenshot below. Create a variable named “communication_freq” with the following possible options: . | Label | Value | . | Last 24 hours | 5 | . | Last week | 4 | . | Last six months | 3 | . | Last two years | 2 | . | Over two years ago | -1 | . By convention, the Network Canvas software uses two terms for the containers that nodes are dragged between on the Ordinal Bin, Categorical Bin, and Sociogram interfaces.Buckets are where nodes are found initially, before they have been placed, or dragged.Bins are where nodes are placed are dragged to. This is where nodes end up.Both bins and buckets can have the sort order of the nodes within them defined. You can use this to (for example) make the bucket show nodes with a certain attribute, such as closeness, first. This may help with a task such as positioning nodes on a sociogram. In the case of our prompt, we will use the default node bin and bucket sort options. Click “Save and Close” to finish editing this prompt, and then click “Save and Return” to return to the timeline view. ",
    "url": "/tutorials/building-a-protocol/#creating-an-ordinal-bin",
    "relUrl": "/tutorials/building-a-protocol/#creating-an-ordinal-bin"
  },"39": {
    "doc": "Building a protocol using Architect",
    "title": "Creating a Categorical Bin",
    "content": "You should now be able to create a categorical bin interface using everything that you have learned so far. Add a new stage using the Categorical Bin interface, with the following characteristics: . | Named “Categorical Group Membership”, and operating on the “People” node type. | Using a categorical variable called “group” with the following options: . | Family Member | Friends | Work Colleague | School | . | With the prompt text, “Which of these options best describes how you know this person?” | Toggle “on” the Follow-up “Other” option with bin label “other”, question prompt “Which context best describes how you know this person?”, and variable “group_other” | . As before, we will “Save and Close” and “Save and Return” to complete and save our edits on the stage. ",
    "url": "/tutorials/building-a-protocol/#creating-a-categorical-bin",
    "relUrl": "/tutorials/building-a-protocol/#creating-a-categorical-bin"
  },"40": {
    "doc": "Building a protocol using Architect",
    "title": "Skip Logic &amp; Network Filtering on the Categorical Bin",
    "content": "Next we will implement another Categorical Bin Interface. This time, we will create the stage as before, set the stage name to “Relationship Type” and select node type as “Person.” . Now we will configure both the network filtering on the stage as well as the skip logic for the stage. First, toggle the “Enable network filtering for this stage” to “on” and press the “Add Alter Rule” button. Next we will configure the rule according to the following: node type “Person”, rule type “Attribute”, variable query “discuss_network_research”, operator “exactly”, and attribute value of “True.” . Click the “Finish and Close” button. To enable skip logic, we toggle the “Enable skip logic for this stage” switch to “on.” Then we click the “Add Alter Rule” again. First, we configure the skip logic rule according to the following: node type “Person”, rule type “Presence”, and operator “Exists.” Next, we configure a second skip logic rule as follows: node type “Person”, rule type “Attribute”, variable query “discuss_network_research”, operator “is exactly”, and attribute value of “True.”. Once configured, ensure the “must match” setting is “all rules”, as above. As a final step on this stage, we will create a prompt with the text, “You indicated that you’ve discussed social networks research with these people. Which category best describes your relationship with each person?” We will assign a categorical variable of “social_networks_research_relationship” with the following labels: Work Colleague, Classmate, Co-author, Supervisor. Type the corresponding values of “Work_Colleague”, “Classmate”, “Co-author”, and “Supervisor.” . We will also include a “Follow-up “Other” Option” for this prompt. Toggle the switch in the section to “on”, type the label for bin of “Other”, type question prompt for dialog as “What is your relationship with this person?” and create a new variable to capture this attribute of “social_network_research_relationship_other.” . We have now finished configuring this stage. Press “Save and Close” on the bottom right of the prompt editor, and “Return and Close” on the Categorical Bin Interface editor. ",
    "url": "/tutorials/building-a-protocol/#skip-logic--network-filtering-on-the-categorical-bin",
    "relUrl": "/tutorials/building-a-protocol/#skip-logic--network-filtering-on-the-categorical-bin"
  },"41": {
    "doc": "Building a protocol using Architect",
    "title": "Creating the Narrative Interface",
    "content": "The last stage configured in this sample protocol is the Narrative Interface. As you have already learned, we will create a new stage (Narrative Interface), set a stage name (“Narrative Interface”), and select a node type (“Person”). Next we will choose to use the concentric circles background, but this time elect to use just 1 circle. Configuring Presets . Narrative presets allow you to emphasize specific elements of a participant’s network visually, such as nodes grouped by attribute characteristic or alter-alter relationships (edges). Once the presets are configured on this screen, they appear as a menu where each option can be toggled “on” or “off.” . Now, let’s configure presets for our sample interview protocol. Go to the section in the Narrative stage editor titled “Narrative Presets” and press the “Create New” button. We will give the preset a label of “Sample Preset.” This label will appear at the top of the menu visible to the participant on this stage. Next, we will click the “Layout Variable” box. We can choose to either create a new layout variable for this screen or use an existing one. In this case, we’ll use the “sociogram_layout” variable we created before. If we have collected data on a categorical variable and the participant has assigned that attribute to at least two nodes, we can visualize this grouping on the Narrative Interface. The drop down menu under “Group variable” will show all available categorical variables in our protocol. In this example, we choose the variable “group.” . Under “Edge types to display”, we will see all edge types defined within our protocol. We will select the checkbox next to the edges we want to display (“know” and “conflict”). The last step in the preset editor is to select any boolean variables we want to highlight on the participant’s network. Again, all available boolean variables will appear in this section and we can choose which of these we want included in the preset. We will select the checkboxes next to both “provides_advice” and “provides_material_support.” To save our work, we click “Save and Close.” . Back on our Narrative Interface edit screen, we can see the sample preset we just created. We will move below to the “Narrative Behaviors” section, and toggle both “Free-draw” and “Allow repositioning” to “on.” (The latter should already be toggled on by default). Free-draw is a function on this interface that allows a participant to annotate on the screen by using their mouse. They can draw lines, symbols, or words that help them describe aspects of their network. Repositioning on the Narrative Interface enables a participant to drag their alters to new positions, keeping the displayed edges intact. Click “Save and Return” and are now able to view the configured Narrative stage on our timeline. ",
    "url": "/tutorials/building-a-protocol/#creating-the-narrative-interface",
    "relUrl": "/tutorials/building-a-protocol/#creating-the-narrative-interface"
  },"42": {
    "doc": "Building a protocol using Architect",
    "title": "Finishing Off Your Protocol",
    "content": "Make sure to save your file. The file name of the protocol will uniquely identify it in both the Network Canvas Interviewer app and Network Canvas Server. There are numerous ways to transition from building the protocol within the Architect to deployment. | Within the Interviewer app, import the protocol file directly from a file location on your local computer. | Host the protocol file on a web server and then within the Interviewer app, import the protocol file from a web URL. | Use Server to manage the workflow. Once the protocol is loaded into Server it can be deployed to multiple field devices and then receive data from these devices for collation and export. | . In the next tutorial, Server and Interviewer Workflows, we will show you how to use Server to load a protocol file onto multiple devices and then receive the data from those devices. ",
    "url": "/tutorials/building-a-protocol/#finishing-off-your-protocol",
    "relUrl": "/tutorials/building-a-protocol/#finishing-off-your-protocol"
  },"43": {
    "doc": "Building a protocol using Architect",
    "title": "Building a protocol using Architect",
    "content": " ",
    "url": "/tutorials/building-a-protocol/",
    "relUrl": "/tutorials/building-a-protocol/"
  },"44": {
    "doc": "Offline Data Management Workflow",
    "title": "Offline Data Management Workflow",
    "content": " ",
    "url": "/tutorials/offline-data-management-workflow/",
    "relUrl": "/tutorials/offline-data-management-workflow/"
  },"45": {
    "doc": "Using Interviewer",
    "title": "The start screen",
    "content": "After opening Interviewer, the first thing you will see is the ‘start screen’. The start screen is a ‘back-stage’ area of Interviewer, designed to enable the person conducting the study to be able to configure the device and manage its data. The start screen is divided into sections that group related tasks together, such as “starting an interview” or “exporting and managing interview data”. The start screen is designed to intelligently show options that are appropriate, and to hide options when they are not applicable. Because of this, when we open interviewer for the first time, we see the three default sections: . The welcome section which contains links to install the sample protocol, visit the documentation website, or watch an overview video. The welcome section can be hidden when no longer needed, using the toggle in the top right hand corner. The welcome section also contains a button (the cog icon) that opens the main device settings screen. We encourage you to open the settings screen and explore the various options. The protocols section which allows you to quickly import a Network Canvas protocol file from a URL or by choosing a file ( and later, also by importing from a computer running Server). Once you have installed one or more protocol files, this section will also contain a button that allows you to manage your installed protocols. The server status section which initially shows nearby computers running Server that you may wish to pair with, and once paired shows the communication status of the device with your paired Server. As you use Interviewer to collect data, sections and options will appear that expose additional functionality as you need it. ",
    "url": "/tutorials/using-interviewer/#the-start-screen",
    "relUrl": "/tutorials/using-interviewer/#the-start-screen"
  },"46": {
    "doc": "Using Interviewer",
    "title": "Installing and managing protocols",
    "content": "Interviewer must be programmed using one or more interview protocols before it can be used to collect data. Once you have authored a protocol file in Architect, there are three ways to import it into your devices running Interviewer. Which one you choose will depend on the needs of your study. | Importing a file directly. This option can be accessed either from the file menu if running Interviewer on Windows/MacOS/Linux, or from the protocols section of the start screen. It provides a simple means to import a protocol file that is already stored on your device. | Importing from URL. This option is accessed from the protocols section of the start screen, and allows you to download a protocol file directly from any URL that is accessible from the device running Interviewer. This option can be useful in circumstances where you have a study website or intranet, and need to quickly install a protocol on a device but you do not wish to use Server as part of your workflow (see “which applications do I need?” for more on this). | Importing from Server. When you have paired your device running Interviewer with a computer running Server, you can securely transfer a protocol file to your interview device by clicking the “Import from Server” option in the protocols section. | . For the purposes of this tutorial, we will proceed using the built-in sample protocol. To follow along on your own device, click the “install sample protocol” button in the welcome section of the app to install the protocol that we will be using. Alternatively, click here to download the file to this device, and then import it into Interviewer using the import from file method described above. Once a protocol has been imported, a new section will appear on the start screen: the start a new interview section. Inside this section will be a protocol card, representing the protocol you imported. By default, this section will show the protocol card for the protocol that you last installed, or last conducted an interview with. Managing installed protocols . To help you to manage protocols that are installed in Interviewer, there is a dedicated overlay. This can be opened from the protocols section, which will now display a “manage installed protocols” button. Once you open this overlay, you can sort your installed protocols, as well as filter them by name. To remove a protocol file from your device, drag its card into the bin that appears at the bottom of the screen. ",
    "url": "/tutorials/using-interviewer/#installing-and-managing-protocols",
    "relUrl": "/tutorials/using-interviewer/#installing-and-managing-protocols"
  },"47": {
    "doc": "Using Interviewer",
    "title": "Starting an interview",
    "content": "Starting an interview involves tapping or clicking the protocol card of the protocol that you wish to use. By default, the last protocol you installed (or started an interview with) is displayed prominently in the start a new interview section, and can be tapped to immediately begin an interview. With the Sample Protocol card visible, click the card to start a new interview session. Using a different protocol . If you have more than one protocol installed in Interviewer, a card stack will appear to the right side of the start a new interview section. To access all available protocols, tap or click this card stack. A dialog will open with a list of protocols currently stored in the app. Scroll, filter, or sort the protocol card list to locate the protocol you wish to use for your interview, and tap or click it to begin. This protocol will then appear in the start a new interview section for quicker future access. Entering a case ID . In Network Canvas, interview sessions can be identified by a number of means. Interviewer and Server both keep track of interviews using a “universal unique identifier” (UUID), which as the name suggests uniquely identifies every interview on every device you are using, without needing to communicate with other devices. However, it is often more convenient to provide a label that identifies an interview session that is meaningful to the researcher. For this purpose, we developed the concept of the “case ID”. A case ID is entered at the start of every interview, and is entirely decided upon by the researcher. It can contain any combination of numbers and letters (including spaces) up to 30 characters. Its only purpose is to identify the interview session in a way that is meaningful to you. There is no requirement that a case ID be unique, since this would not be possible to ensure across multiple devices. Nevertheless, you should strongly consider a consistent system for naming cases that allows you to uniquely identify them. For example, you might consider: . | INTERVIEWER_INITIALS PARTICIPANT_ID DATE (e.g JRM 12345 December 5th) | STUDY_ID-PARTICIPANT_NAME-VISIT_NUMBER (e.g NetCanvas-Joshua-4) | or simply PARTICIPANT_NAME (e.g James Montgomery Williams) | . The case ID is shown in the “resume last interview” section, the “export and manage interview data” section, the case management view in Server, and also appears in the default filename of exported data. Enter a case ID, and click “start interview” to begin. The case ID of an interview can be changed from the menu when within the interview. Simply click the menu icon, and click the ‘edit’ button in the white session summary card that appears on the right. ",
    "url": "/tutorials/using-interviewer/#starting-an-interview",
    "relUrl": "/tutorials/using-interviewer/#starting-an-interview"
  },"48": {
    "doc": "Using Interviewer",
    "title": "Interviewer user-interface",
    "content": "Interviewer’s user interface is designed to be simple, unobtrusive, and intuitive for participants. This has two main consequences: (1) much of the functionality researchers may wish to access is somewhat less discoverable than you might be used to, and (2) very little space is devoted to user interface elements that provide explanations about how to complete a task. This is because we assume that the researcher will be able to guide the participant through the interview process, as appropriate. In terms of the user interface elements that are always visible when within the interview, there are several features of note. The menu button at the very top of the screen opens the primary app menu, which allows you to: . | Exit the interview | See a summary of the session, including numbers of nodes and edges and current duration | Open the device settings menu | Open the stages menu (see below) | . The large vertical bar is the interview timeline, which is a visual indicator of progress through the interview. As the participant progresses forwards the bar will fill up, and eventually turn green when the interview is finished. Tapping the timeline will reveal the “stages menu”, which allows the researcher to quickly see precisely where they are within the interview, as well as to move to another location. The stages menu can also be opened from the main app menu. Moving forwards and backwards through the interview is accomplished using the next (down arrow) and previous (up arrow) buttons visible at the top and bottom of the timeline, which can be used by the participant or by the researcher to advance the interview. The next button at the bottom left of the screen is particularly important to explain to the participant. ",
    "url": "/tutorials/using-interviewer/#interviewer-user-interface",
    "relUrl": "/tutorials/using-interviewer/#interviewer-user-interface"
  },"49": {
    "doc": "Using Interviewer",
    "title": "Sample interview walkthrough",
    "content": "We will now continue through the sample interview protocol. If you are following along on your own device, make sure you have started a new interview, entered a case ID, and are looking at the first screen. To go forwards or backwards, use the next and previous buttons we discussed above. Stages and interfaces . With Network Canvas, each interview is made up of a series of screens that we call “stages”, where a specific task is to be completed. You can have as many stages in your interview as you feel you need, and as you will see in other tutorials, there are many ways to structure your interview using different combinations of screens and different front or back loadings of tasks. Each stage is an instance of a category of task-based screen that we call an “Interface”. That is to say that an Interface is the broad “type” of task, and a stage is the specifically configured version of that task embedded in your interview. For example, Network Canvas has several “name generator” Interfaces, but the specific screen at the start of your interview may be called the “person name generator stage”. Each Interface is designed for a specific data collection task, such as generating names, collecting ordinal data, or showing a form. Each Interface has dedicated documentation (see the “Interface Documentation” section on the left) that explains its features, and gives hints about when and where you should use it. The information interface . The first thing we see after starting the interview is the welcome stage, which is configured using the information interface. The information interface can be used to communicate information to a participant, such as a study description or instructions for completing a task on a subsequent screen. It can also contain media, such as audio, images or video. We have used numerous Information Interfaces throughout this sample protocol to clarify the primary tasks performed in Interviewer, but we will not describe them in this article to avoid redundancy. Name Generators . After clicking through the information screens, we encounter the first name generator stage of our interview, which is where the participant will name alters. Name generation is clearly a fundamental task in all network interviewing, and so Network Canvas offers configurable and customizable behaviours to suit different research designs. We will now briefly discuss these in turn, in the context of the sample protocol. Quick add . Our first stage uses the “quick add” name generator Interface, which is designed to be ultra-low response burden, and only require that a participant provide a name or label to create a node. We add nodes by clicking the button on the bottom right, typing a name, and pressing enter (or clicking the node icon). When you are finished, either click the button again, or click away, to close the input. The stage is configured with a single prompt (“Within the past 6 months, who have you felt close to, or discussed important personal matters with”). Prompts are defined by the researcher for a given stage, and frame the data collection task. Many Interfaces support the use of multiple prompts on a stage. If a stage is configured with multiple prompts, the “next” and “previous” buttons will move between them automatically. Side panels . Clicking forwards into the next name generator stage, we see a side panel appear that contains all of the nodes named on the first stage. We can drag and drop nodes from the side panel into the node list area or we can create new nodes by clicking on the button in the bottom right right corner. The side panel functionality is available in both of our non-roster specific name generator Interfaces. It is designed for two specific scenarios: . | To allow participants to nominate alters they have already mentioned again in response to later prompts. For example, if a first prompt asks “Who are you close to?”, and second prompt asks “Who are your family members?”, the participant may wish to nominate existing close alters as also being family members. This is especially powerful when used in combination with the assign additional variables feature. | As a container for displaying small amounts of roster data, where you still need to retain the ability for the participant to add network members not listed in the roster. | . You can display up to two panels, with different content in each. More information about can panels can be found here. Forms . Moving forwards until you arrive at the next name generator, you will find a prompt asking about clinics or healthcare providers. This stage demonstrates two important concepts. The first is that the name generators in Network Canvas can be configured to collect more in-depth node information at the time of elicitation. In this example, clicking the “add” button in the bottom right shows a form with three fields (name, visit date, and treatment summary). This is the “form” version of the name generator interface. The form you design for your name generator can collect whichever variables you wish, and is one of the key ways that a researcher can vary the front-facing response burden of naming alters. Collecting many variables as the node is created can allow for fewer overall stages in your interview, but can also condition the participant against naming large numbers of alters. The second important concept illustrated on this stage is that Network Canvas interviews can collect data on as many node types as the researcher desires. In this case, our name generator will create “clinic” nodes, which are displayed in blue, as opposed to the red “person” nodes we saw previously. This is an element of the ontological flexibility discussed in our project overview, and allows for powerful research designs that model networks in sophisticated ways. Using roster data . Continuing forwards through the sample protocol, we arrive at another name generator - but one that behaves differently to the others. This stage allows a participant to nominate alters from a predetermined list (i.e., a roster). In this case, “classmate” nodes are added by selecting the appropriate “display card” on the scrollable roster. Multiple class members (alters) can be added at one time. Note that you are able to filter and sort the list. The sortable properties, as well as the information to be displayed on the cards, are all fully customizable by the researcher. Once a member of the roster has been nominated, Interviewer creates a node in the network interview using data from the roster. This results in data files that contain only the nodes that the participant nominated. Clicking next again will take us to a second roster-based name generator Interface, but this time designed to work for extremely large rosters. Here, we ask about universities visited or studied at, and our CSV roster data file contains approximately 9,300 nodes. Since this roster is so large, this Interface does not display the roster in its entirety. Instead, it offers a search box, and customizable levels of fuzzy matching, in order to help the participant quickly locate the nodes they wish to nominate. What differentiates these Interfaces is the size of the roster data that they are designed to accommodate, and the user interface affordances offered to the participant to help them to locate the roster member they are looking for. Visit our dedicated page to learn more about working with roster data. Ego data collection . While Interviewer is optimized for collecting data about network members from an ego-centric perspective, we also provide the ability for researchers to capture data about the participant (ego). As you will learn when constructing a protocol, it is not required that a Network Canvas protocol ask the participant about themselves, but it is a common approach within many network studies. The ego form Interface (stage 12 within the sample protocol), allows the researcher to show an arbitrary form to the participant, where responses will be stored in a dedicated section of the interview session devoted to ego data. In this particular stage, we ask for a variety of individual level data using numerous input control types. The form includes validation, which requires you to enter the first and last name before proceeding onto the next screen. Such validations can be useful in preventing missing data. General purpose form interfaces . For other situations where general purpose data collection is required, we provided form-based interfaces targeted at both nodes and edges. By clicking next, we come to a stage using the per-alter form Interface. This Interface can be used to ask name interpreter questions about alters the participant has nominated. The researcher is able to choose which alter type is used, as well as to define the form itself. Any data in these forms is stored directly on the alter as an attribute. In this particular Per Alter Form, we ask whether you visited or studied at the university you nominated and to indicate your level of satisfaction with the experience. The Per Alter Form stage will cycle through all alters of a given type in the interview network, unless skip logic or network filtering have been implemented causing the stage to be skipped altogether or filtering only a subset of the alters on the stage, respectively. As with all forms used by Interviewer, the Per Alter Form allows you to capture different types of data in a series of fields utilizing a variety of input controls. There is also a per alter edge version of this interface, which is identical except for dealing with edges between alters, rather than alters themselves. It can be used to ask edge interpreter questions about the quality of a given relation. The sociogram interface . Next is the sociogram Interface. Network Canvas has been heavily inspired by the long tradition of using visual methods in social networks research, which often features the sociogram as a means of presenting the network in a way that is intuitive to participants. The sociogram in Interviewer is capable of three main tasks: . | Positioning nodes spatially - this means allowing the participant to drag (with touch or using a mouse) nodes around the sociogram, and place them according to some criteria. The sample protocol demonstrates the use of different background types, with the first stage showing concentric circles, and the second using an image of the “political compass”. | Creating edges or links between nodes - by tapping consecutively on one node followed by another, a link representing an edge can be visually created. The sociogram can create and display multiple edge types. | Nominating nodes as having an attribute - when not in edge creation mode, the sociogram can be configured so that tapping a node toggles the value of a boolean variable. This powerful feature allows you to use the participant-defined spatial and structural dimensions of the network to reduce the response burden of finding and nominating members of the network. | . As with other Interfaces, every aspect of theses three behaviours is customized by the researcher. The layout information is stored in a variable defined by the researcher, who also defines the prompts, the background image, the edge types, and the attributes to nominate. Conducting a dyad census . Other research has preferred more systematic approaches to evaluating the presence of alter-alter relations in ego networks. Continuing to stage 19 in the sample protocol illustrates the dyad census Interface, which has been designed to accommodate these methods. On this stage, all previously named alters are presented under a researcher-defined prompt and a simple “yes”/”no” user interface. By clicking the ‘yes’ button, a tie between the alters is created. By clicking the ‘no’ button, no edge is created. All possible pairs within the network for a particular node type will appear, unless network filtering is implemented to only show alters with specific attributes (e.g., class members). The horizontal green bar along the bottom of the screen will fill from left to right indicating the overall progress of the task. The larger the network, the greater the response burden is for the Dyad Census. As demonstrated in the previous stages, the Sociogram Interface also allows for alter-alter edge creation but instead displays the whole network visually to allow a participant to confirm relationships where they exist rather than cycle through all possible connections. Ordinal and categorical data . Apart from general purpose form Interfaces, Interviewer also contains a variety of dedicated name-interpreter Interfaces that are designed to improve the experience of collecting a single variable on a per-alter basis. Stage 23 in the sample protocol is an example of the ordinal bin Interface, which as the name suggests deals specifically with ordinal variables. The Ordinal Bin Interface allows you to drag nodes into a “bin” representing an ordinal variable value, and thereby to assign that value to the alter. This interface greatly improves response burden of “matrix type” questions, where the same question is asked for each alter that has been nominated. Here, we ask, “When was the last time that you communicated with each of the people you named?” Drag any nodes you have named into the appropriate bin. If you decide that a node was placed incorrectly in a particular bin, you can move the node to the appropriate bin by dragging it into place. Once again, the key elements of the Interface are set by the researcher, including the alter type, the ordinal variable (and its categories), the color scheme of the bins, and the prompt(s). The next stage uses the categorical bin Interface, which allows you to drag nodes into colorful circles, each representing a categorical variable value. When a node is placed within a circle the variable value is assigned to that alter. You can view which nodes were placed in which circle by selecting the circle. This action allows you to move nodes from one circle to another, which may be necessary to correct an error. Managing interview flow with skip logic and network filtering . One of the simplest ways to reduce response burden in an interview is to avoid showing the participant tasks that are not applicable or redundant based on earlier answers. In conventional survey software sections of an interview can be skipped based on responses, but Network Canvas extends this concept and allows the researcher to construct powerful queries built on the structure of the interview network itself. These queries can be applied to both skip logic and stage level network filtering. On stage 26 we encounter another categorical bin task, but time time using these features to reduce response burden. Skip logic rules have been defined which direct that the stage should only be shown only if a participant has named any alters of type “Person” with whom they discuss social network research. Recall the quick add name generator on stage 6 that asked participants to list any people with whom they have discussed social networks research: nodes nominated on that stage were given an attribute which we have used to create this skip logic query. If no alters were generated on that screen, the current categorical bin will be skipped. Similarly, network filtering is configured using a rule which filters out all alters on this stage except those with whom the participant has discussed social networks research. This minimizes the scope of the task, and removes the need to add a “not applicable” category. You may wish to navigate back and forth between the quick add name generator and this stage to see the skip logic and network filtering in action. Remember that at any time during the interview, you can view a menu of all protocol stages by tapping on the timeline. Tapping on a stage will navigate to it. The Narrative Interface . The final stage of the sample protocol demonstrates an Interface that is designed for qualitative personal network’s research. The narrative Interface does not collect any additional data, but rather can map data collected elsewhere in the interview to aspects of the visual representation of the network. It therefore aims to represent aspects of the participant’s network back to them, with the intent to facilitate narrative interrogation of the data in an interview setting. The preset menu in the bottom right allows the researcher or the respondent to switch between different predefined visual styles. In this example, we can see the two edge types we created previously (“know” and “conflict”) and the boolean attributes we assigned during our variable toggling task on the Sociogram Interface. We can also see the categorical groupings collected on the Categorical Bin Interface. Each preset can be toggled on or off by tapping on the attribute or edge in the menu. The narrative Interface also supports free-form annotation using the mouse, a finger, or a stylus. The annotation will disappear in five seconds unless you click the freeze icon to the left of the preset menu. With the freeze button engaged, all annotations will remain until you disable the freeze function or use the reset annotation button. Although these annotations are not yet recorded by the software, you can optionally use additional screen recording and audio recording software to keep a record of the interactions on this Interface. The Finish Screen . Each interview protocol has a “finish” screen automatically inserted by Interviewer. This screen presents a single button that will exit the interview and return to the start screen. Clicking this button will also set, or update, the “finished at” property of the interview session. This property is exported along with your interview data, and can be used to calculate interview duration. For now click “Finish” to return to the start screen. ",
    "url": "/tutorials/using-interviewer/#sample-interview-walkthrough",
    "relUrl": "/tutorials/using-interviewer/#sample-interview-walkthrough"
  },"50": {
    "doc": "Using Interviewer",
    "title": "Resuming, exporting, and managing interview sessions",
    "content": "Now that you have completed an interview, new sections and options will appear on the start screen for managing and resuming interview sessions. The resume section (above) is displayed immediately below the start new interview section, and works in the same way. Clicking an interview session card will immediately resume the interview at the point that you left off. When multiple existing sessions exist on the device running Interviewer, a card stack icon will appear, that when clicked will allow you to choose between resuming any existing interview session. Managing and exporting interview data takes place in a dedicated export and manage interview data section (below). To remove an interview session from the device, select it, and click the “delete selected” button. The data export process consists of selecting one or more sessions from this section, and clicking the “export selected to file” or “export selected to Server” button, as applicable. Settings for exported data can be found in the device settings in the welcome section. ",
    "url": "/tutorials/using-interviewer/#resuming-exporting-and-managing-interview-sessions",
    "relUrl": "/tutorials/using-interviewer/#resuming-exporting-and-managing-interview-sessions"
  },"51": {
    "doc": "Using Interviewer",
    "title": "Next Steps",
    "content": "Now that you have experienced the general flow of an interview in Network Canvas Interviewer from the participant perspective, you may wish to learn about how to begin to create your own protocol. For this, we suggest our article on building a protocol using Architect. ",
    "url": "/tutorials/using-interviewer/#next-steps",
    "relUrl": "/tutorials/using-interviewer/#next-steps"
  },"52": {
    "doc": "Using Interviewer",
    "title": "Using Interviewer",
    "content": " ",
    "url": "/tutorials/using-interviewer/",
    "relUrl": "/tutorials/using-interviewer/"
  },"53": {
    "doc": "Using Server to manage a study",
    "title": "Introducing Network Canvas Server",
    "content": "Server is an optional companion program to Interviewer and Architect. Server is used to: . | Ensure the same interview protocol is deployed on multiple devices, | Manage the data from multiple devices in a single location, | Securely store data on a lab computer, | Monitor the progress of the study in the field, | Display brief data summaries on key protocol variables, and | Export the data of multiple interview files in a format suitable for analysis. | . Server is not required to run a Network Canvas study. Protocols can be designed in Architect and opened directly in the Interviewer application, which may be sufficient for small studies using a single device. However, if your study entails working with many cases on multiple devices and maintaining your case files in a single location, Server will be a useful component to your project workflows. In Server, you can back up your case files while conducting research in the field. Through the secure pairing process (detailed below) Server allows you to securely transmit a copy of your data directly to your lab device. If a network connection is unavailable when you conclude an interview, you are also able to save a copy of your data on the field device and transmit the data immediately to Server once a connection can be restored. Server is particularly useful when you have multiple devices in the field that all need to transmit interview data to a single location. Each device can be connected to a single instance of Server, which allows you to view cases as they are uploaded and monitor the progress of your project in real time. From this same instance of Server, you are able to export all of your social network data in a format suitable for analysis in standard network and statistical software packages. | Key Concepts: Encryption for Data Security | . | Server is a desktop program run by the researcher on their own computer. Getting data from Interviewer into Server requires “pairing”. To pair, Server produces a unique encryption key that must be manually entered into the Interviewer application running on a field device. Once paired, Interviewer is able to securely transmit data collected in the field directly to Server. Utilizing Server allows you to avoid using third party servers, such as Dropbox or Google Drive, and instead transfer your data directly to a computer with full-disk encryption (such as FileVault on Mac or BitLocker on Windows). Transferring data to Server in this way is an example of peer-to-peer connection whereby only your field device and your copy of Server are able to access your data. | . The start screen of Server provides instructions for how to create a workspace for your protocol and how to pair a device to facilitate secure encrypted data transmission. The icons in the top right corner of the screen also provide important details about the network connectivity of the computer running Server. These details can be used to manually pair Server to Interviewer field devices if necessary (details on manual pairing below). Importing a Protocol to Server . A .netcanvas protocol file can be imported into Server by 1) dragging the file directly into the sidebar of the Server, 2) using the + button to open a file dialog to manually select the file, or 3) selecting ‘Import Protocol’ from the file menu to browse and select your file. Once imported, Server will create a dedicated workspace with an “overview dashboard” for this protocol file. This process occurs for every protocol you import, allowing you to have multiple protocols / studies running in parallel in Server. Each unique overview dashboard is navigable by selecting the appropriate protocol initials on the side bar. After a protocol is imported into Server, it is ready to be deployed to Interviewer on your field device(s) once secure pairing is completed. To preserve the quality of your data, it is not possible to change most of the details of a protocol once in use. If a protocol is in the field and the question names and ordering are changed it will make it difficult, if not impossible, to export all this data in a single table. Every time you export interview data to Server, these data will immediately update and display on the overview dashboard linked to the specific protocol. | Key Concept: The overview dashboard | . | The overview dashboard displays key details about your study and updates in real time as new interview data are uploaded. The dashboard will show details like the name of the protocol, the number of interviews completed and summary statistics from your study, such as the number of alters named per interview. This dashboard allows you to monitor the progress of your social network studies as well as help you identify potential issues in the data, such as an interviewee who nominates far more or fewer alters than the others. The ‘cards’ that display such information on the dashboard can be reordered by dragging, and toggled on and off in the “Settings” tab. The “Export Data” tab allows you to determine export file type and content, and the “Manage Cases” tab allows you to view a complete list of all cases exported to Server associated with a particular study protocol. | . Once your interview protocol is imported, the next step is to securely pair Server with your field device(s). Pairing Server with your field device(s) establishes a secure connection that allows you to 1) deploy your protocol to the Interviewer application running on the field device(s), and 2) securely transmit data collected back to the Server for monitoring and export. Note: a ‘field device’ is any device that collects data using Interviewer. It could be a tablet or the very same computer running Server. ",
    "url": "/tutorials/using-server/#introducing-network-canvas-server",
    "relUrl": "/tutorials/using-server/#introducing-network-canvas-server"
  },"54": {
    "doc": "Using Server to manage a study",
    "title": "Pairing a Field Device Running Interviewer with Server",
    "content": "To use Server with a field device, you will first have to pair the device with Server. Pairing requires exchanging encryption keys between Server and the field device. Once paired, you can download a protocol from Server to Interviewer and upload data collected in Interviewer back to Server. To begin, make sure you have both Interviewer and Server programs open and running on the same network. With Interviewer open on your field device, scroll down to the ‘Server Status’ panel at the bottom of the start screen. Interviewer will automatically search for any Servers available on the same network. This process is called ‘automatic discovery.’ If Interviewer detects an instance of Server, it will appear as a card on the panel displaying the name of the computer, IP address, and network on which the Server program is running. To trigger the pairing process, click the card. The Interviewer screen will then show a message that the pairing request has been initiated and must now be acknowledged within the Server app. Next, you will acknowledge the request to pair the devices by clicking the pink “Pair with Device” button in Server. Once the request is acknowledged, Server will produce a unique 16 character encryption code that must be typed into the Interviewer app in order for the devices to pair successfully. The encryption code produced by Server must now be typed into the dialog appearing in Interviewer. Note: once the encryption code is provided by Server, you have 30 seconds to submit it to Interviewer before the pairing window will time out. If that window passes, you can reinitiate the pairing process or else pair manually. After you submit the encryption code in Interviewer, you will see notifications on both apps that the pairing was completed. Once paired, Interviewer can fetch protocols from Server and upload data back to Server. | Key Concept: Automatic Discovery &amp; Manual Pairing | . | Automatic discovery is a feature that allows Interviewer to find Server automatically so long as both devices in question are on the same network connection (i.e. the same WiFi or wired Ethernet connection). This feature is available on both Windows and Mac computers, but not Linux.If automatic discovery fails or is unavailable (which can occur if you are on a highly secured network), you can manually facilitate the pairing process between Server and the field device running Interviewer. To manually pair, select the white “provide manual connection details” button on the bottom right corner of the “Server Status” panel in Interviewer. You will be prompted to enter the Server IP address and Pairing Port number, both of which can be found by clicking on the network status icon in the top right corner Server. Once these details are provided, the field device will search for Server to pair.Problem solving: If you cannot reach Server using automatic discovery or the manual pairing steps, try the following: 1) make sure Server is open, 2) restart Server and Interviewer on their respective devices (note: restarting will not drop data), 3) contact your network administrator or refer to the details of the error message for further troubleshooting tips.Some details that might help your network administrator: Server uses the Bonjour protocol and requires multicast DNS packets to be able to pass through the network. | . ",
    "url": "/tutorials/using-server/#pairing-a-field-device-running-interviewer-with-server",
    "relUrl": "/tutorials/using-server/#pairing-a-field-device-running-interviewer-with-server"
  },"55": {
    "doc": "Using Server to manage a study",
    "title": "Some Guidance on Pairing",
    "content": ". | A field device can only pair with one Server at any given time, but a Server can deploy multiple protocols and be paired with multiple field devices simultaneously. If you want to pair with a new instance of Server, the connection to the formerly paired Server will be removed. Protocols that exist on the device will not removed, nor will any cases that have not been uploaded. | You can see what devices are paired with Server by clicking on the ‘devices’ icon in the upper right corner of the app. From there, you can check to see what devices are paired and remove any devices which should not be paired. Note: cleaning out old paired devices is not necessary nor will maintaining a list of old devices on Server affect performance. | If a field device is not paired with a Server before the interview, you can pair with it at a later time. This can be done from the start screen of Interviewer by going to the “Server Status” panel and initiating the pairing process through automatic discovery or pairing manually. Please note that the protocol must have already been uploaded to Server even if the device is not currently paired. You cannot “push” a protocol upstream to Server, only download a protocol that already exists and upload a new interview case. | Server will not enforce unique Case IDs. Instead, there is an internally generated UID which will be unique for all cases. Distinguishing cases based on Case ID is the interviewer’s responsibility. | . ",
    "url": "/tutorials/using-server/#some-guidance-on-pairing",
    "relUrl": "/tutorials/using-server/#some-guidance-on-pairing"
  },"56": {
    "doc": "Using Server to manage a study",
    "title": "Importing a Protocol in Interviewer",
    "content": "There are three ways to import a protocol in Interviewer: from a URL, from a file, and from Server. To fetch a protocol from a URL, click the “Import from URL” button on the start screen of Interviewer under the “Protocols” panel. A dialog will appear where you can enter the URL where your protocol is hosted. To import a protocol as a file, click the “Import from File” button. A new dialog will appear that allows you to browse for the file you want to import. When you locate the file, click “open” to import the protocol into Interviewer. Note: remember only .netcanvas files can be read by Network Canvas applications. To import a protocol from Server, click the “Import from Server” button. You will then see a dialog containing all protocols currently uploaded to the instance of Server to which you are paired. Each protocol will display as a card. Click the card of whichever protocol you wish to import. Once you have imported a protocol to Interviewer, you will be able to view it displayed as a card under the “Start a New Interview” panel on the start screen. Click on the protocol you wish to use to collect interview data. ",
    "url": "/tutorials/using-server/#importing-a-protocol-in-interviewer",
    "relUrl": "/tutorials/using-server/#importing-a-protocol-in-interviewer"
  },"57": {
    "doc": "Using Server to manage a study",
    "title": "Exporting and Managing Data in Interviewer",
    "content": "All interviews completed in Interviewer will appear as cards in the “Export &amp; Manage Interview Data” of the app start screen. Each card represents a unique interview session and contains: . | the case ID, | the name of the protocol used to conduct the interview, | the date and time the interview was initiated, | the date and time the interview was completed, | the percentage complete, and | the export status of the interview data. | . In this panel, cases can be sorted by “last changed”, “case ID”, or “progress.” You can also filter cases by case ID. Case Selection . Cases can be selected individually by tapping on the card. You can also select all unexported cases or select all cases by toggling the corresponding switches in the bottom right of the panel to “on.” . Once cases are selected, there are three actions you can complete from this panel: 1) delete selected cases, 2) export selected cases to Server, and 3) export selected cases to a file. Each action has a corresponding button at the bottom of the panel. Deleting selected cases from Interviewer permanently deletes the data, so only complete this action if you are absolutely sure that your data have already been saved in a secure location or that you will not be requiring the data from these cases. When you export selected cases to Server, Interviewer will indicate whether the upload was successful. You can also cross check the data was successfully uploaded to Server by viewing the overview dashboard for the protocol workspace you are using, which will show the case IDs in real time. If you export selected cases to a file, a dialog will appear for you to save the zip to a location of your choice. Before exporting interview data to a file from Interviewer, be sure the ‘Data Export Options’ are configured to meet your needs. By default, interview data from interviewer will export in GraphML unless you toggle the CSV export option. Configure data export options in the Settings menu by clicking the gears icon in the top left of the start screen. ",
    "url": "/tutorials/using-server/#exporting-and-managing-data-in-interviewer",
    "relUrl": "/tutorials/using-server/#exporting-and-managing-data-in-interviewer"
  },"58": {
    "doc": "Using Server to manage a study",
    "title": "Managing and Exporting Data in Server",
    "content": "Server’s overview dashboards allow you to monitor data quality and project progress for each of your studies. The overview dashboard of each protocol workspace tracks the total number of nodes (across all node types) as well as some average node statistics and the date the interview was uploaded. It will also give a list of the five most recent cases that have been uploaded. Manage Cases . Under the “Manage Cases” tab you can find the complete list of uploaded cases for the study protocol. You can use this list to cross check the uploaded cases from your devices. Cases can also be deleted from Server by selecting the checkbox next to the case and clicking the green “Delete Selected Cases” button at the top of the case list. Export Data . Every completed interview can be exported from Server under the “Export Data” tab. Under this tab you can: 1) select one or more preferred data export formats (CSV and GraphML), 2) choose export options, and 3) select CSV specific file export options. Settings . As noted above, the “Settings” tab is where you are able to toggle “on” or “off” the presence of specific study metrics on the overview dashboard of the protocol workspace. From this tab, you can also delete a workspace. Note: deleting a workspace will permanently remove a copy of the protocol file and any associated data that has been imported from Server. File Type . A CSV file is a comma separated file of values. This is readable as a table (or series of tables) in Excel, LibreOffice, Keynote, and other tabular programs. The CSV version also complies with the egor package standard. This is a specification for egocentric data in R. A GraphML file is a file that is compliant with many social network analysis programs including UCINET, Gephi, NodeXL, Pajek, Visone, ORA and others. While the CSV files will have separate files for edges, egos and alters, the GraphML file contains data on ego, alters, and edges in the same file. This means it cannot be tabular (i.e. used in Excel) but it can still be effectively read by using the network analysis packages above. We recommend entering some test data in Interviewer and exporting it before going into the field. This is to confirm your data structure is as expected. Interview Networks . Networks can either be seen as individual cases or as part of one large set of nodes and edges. The option to “Merge Sessions by Protocol” under the “Export Data” tab will produce a consolidated file for all the cases in the data on a per-protocol basis. If this option is not selected, the file export will produce a folder with a separate file for each of the interviews completed. This will include all the data for that case. The filename will be the name of the case followed by the unique system ID for that case. | Ego file: This will have one row per ego, with ego-level variables and some summary statistics. The key will be caseID_uid | Alter file: This will have one row per alter (i.e. per nominated node). Alters will have their own unique ID. The alters can be linked to their respective ego through the key caseID_uid | Edge file: This will have one row per relationship. Each row will have a key to link to ego (caseID_uid), the ID of alter 1, the ID of alter 2, and any edge-level variables. | . While we try to make the export of data as painless as possible, complex data often requires considerable data wrangling nonetheless. For example, if you have two node types (e.g., “Person” and “Place”), then they will both exist in any exported data. If you only want networks between people, then you will have to manually remove the other place nodes. We cannot overstate how important it is to test the collection and export of these data before going into the field. Being unable, for example, to distinguish whether a node was nominated from one prompt or another is possible but might seriously impede analysis. Consider utilizing the data export features in Server to view your data before your study begins. ",
    "url": "/tutorials/using-server/#managing-and-exporting-data-in-server",
    "relUrl": "/tutorials/using-server/#managing-and-exporting-data-in-server"
  },"59": {
    "doc": "Using Server to manage a study",
    "title": "Using Server to manage a study",
    "content": " ",
    "url": "/tutorials/using-server/",
    "relUrl": "/tutorials/using-server/"
  },"60": {
    "doc": "Working with Network Canvas data in R",
    "title": "Initial setup",
    "content": "Set the path to your data files below. dataDirectoryPath &lt;- '~/Desktop/networkCanvasExportMerged' # merged dataset used for now stopifnot(dir.exists(dataDirectoryPath)) file_name &lt;- 'Joshua_caa8fa0b-a66b-4f34-ada0-502ec1f76667_attributeList_Person.csv' # Get a list of all files dataFileList &lt;- list.files(dataDirectoryPath, pattern=NULL, all.files=FALSE, full.names=TRUE) # todo iterate dataFileList, filter into cases, and create a list of ego, alter, and edge dataframes per case egoDataFrame &lt;- read.csv(dataFileList[7]) alterDataFrame &lt;- read.csv(dataFileList[3]) edgeDataFrame &lt;- read.csv(dataFileList[6]) . Import the ego-r package, and any other packages we might use . library(egor) . Create an egoR object from our dataframe . tf &lt;- threefiles_to_egor( egos = egoDataFrame, alters = alterDataFrame, edges = edgeDataFrame, ID.vars = list(ego=\"networkCanvasEgoUUID\", alter=\"networkCanvasUUID\", source=\"networkCanvasSourceUUID\", target=\"networkCanvasTargetUUID\") ) . ",
    "url": "/tutorials/working-with-data/#initial-setup",
    "relUrl": "/tutorials/working-with-data/#initial-setup"
  },"61": {
    "doc": "Working with Network Canvas data in R",
    "title": "Converting categorical variables to factors",
    "content": "Convert categorical variable format into factors. catToFactor &lt;- function(dataframe,variableName) { fullVariableName &lt;- paste0(variableName,\"_\") catVariables &lt;- grep(fullVariableName, names(dataframe), value=TRUE) # Check if variable exists if (identical(catVariables, character(0))){ stop(paste0(\"Cannot find variable named -\",variableName,\"- in the data\")) # Check if \"true\" in multiple columns of a single row } else if (sum(apply(dataframe[,catVariables], 1, function(x) sum(x %in% \"true\")&gt;1))&gt;0) { stop(paste0(\"Your variable -\",variableName,\" - appears to take multiple values.\")) } catValues &lt;- sub(paste0('.*',fullVariableName), '', catVariables) factorVariable &lt;- c() for(i in 1:length(catVariables)){ factorVariable[dataframe[catVariables[i]]==\"true\"] &lt;- catValues[i] } return(factor(factorVariable,levels=catValues)) } # List of categorical variables in our protocol to convert into factors categoricalVariablesList &lt;- list('group', 'social_networks_research_relationship') # Iterate the list and call our catToFactor function, assigning the result to a new column in our dataframe for (variable in categoricalVariablesList) { dataFrame[variable] &lt;- catToFactor(dataFrame, variable) } . ",
    "url": "/tutorials/working-with-data/#converting-categorical-variables-to-factors",
    "relUrl": "/tutorials/working-with-data/#converting-categorical-variables-to-factors"
  },"62": {
    "doc": "Working with Network Canvas data in R",
    "title": "Working with Network Canvas data in R",
    "content": " ",
    "url": "/tutorials/working-with-data/",
    "relUrl": "/tutorials/working-with-data/"
  },"63": {
    "doc": "Choosing Hardware for a Network Canvas Study",
    "title": "Choosing Hardware for a Network Canvas Study",
    "content": " ",
    "url": "/how-to/choosing-hardware/",
    "relUrl": "/how-to/choosing-hardware/"
  },"64": {
    "doc": "Configuring Devices Prior To Starting Data Collection",
    "title": "How to disable app auto-updates on Android devices",
    "content": ". | Open the Google Play Store app. | On the upper left side of the screen, tap the menu icon. | Tap “Settings”. | Tap “Auto-update apps”. | Tap “Don’t auto-update apps”. | Tap “Done”. | . ",
    "url": "/how-to/configuring-devices/#how-to-disable-app-auto-updates-on-android-devices",
    "relUrl": "/how-to/configuring-devices/#how-to-disable-app-auto-updates-on-android-devices"
  },"65": {
    "doc": "Configuring Devices Prior To Starting Data Collection",
    "title": "How to disable auto-updates on iOS devices",
    "content": ". | Tap on the Settings App on your main screen . | Tap on General &gt; Software Update &gt; Automatic Updates . | Disable automatic updates by switching it off . | . ",
    "url": "/how-to/configuring-devices/#how-to-disable-auto-updates-on-ios-devices",
    "relUrl": "/how-to/configuring-devices/#how-to-disable-auto-updates-on-ios-devices"
  },"66": {
    "doc": "Configuring Devices Prior To Starting Data Collection",
    "title": "Configuring Devices Prior To Starting Data Collection",
    "content": "This article is work in progress, and will be developed in the coming days and weeks to contain more information. For the time-being, we are simply advise users to disable automatic updates on their devices prior to starting data collection. You should also follow typical best-practices regarding device security, such as enabling pass-codes and encryption. These topics will be discussed as this article is updated. ",
    "url": "/how-to/configuring-devices/",
    "relUrl": "/how-to/configuring-devices/"
  },"67": {
    "doc": "Exporting Data from Interviewer",
    "title": "Exporting Data from Interviewer",
    "content": " ",
    "url": "/how-to/exporting-data-from-interviewer/",
    "relUrl": "/how-to/exporting-data-from-interviewer/"
  },"68": {
    "doc": "Import a Protocol into Interviewer",
    "title": "Import a Protocol into Interviewer",
    "content": " ",
    "url": "/how-to/import-a-protocol/",
    "relUrl": "/how-to/import-a-protocol/"
  },"69": {
    "doc": "Importing Roster Data",
    "title": "Importing Roster Data",
    "content": " ",
    "url": "/how-to/importing-roster-data/",
    "relUrl": "/how-to/importing-roster-data/"
  },"70": {
    "doc": "Pairing Interviewer Devices with Server",
    "title": "Connecting to Server",
    "content": "Automatic Discovery . Pairing can be accomplished manually or via the automatic discovery feature, which works using a technology called mDNS (also known as ZeroConf and Bonjour). If you are running macOS, the technology needed for automatic discovery is already installed. For Windows users, you will have been prompted during the installation to install the additional components required. You can reinstall them at any time by reinstalling Interviewer. Using this technology, Interviewer clients are able to “see” instances of Network Canvas Server that are running on the same local area network (LAN). Interviewer will automatically attempt to locate instances of Server running on the same network, and any that are available to pair with will be visible by scrolling to the bottom of the Interviewer’s start screen, in the “Server Status” section. Ensure that the instance of Server you wish to pair with is open and connected to the same network as the Interviewer client so they can “see” each other. Each instance of Server found is displayed as a card, with a hostname as a label. Click the instance of Server you wish to begin pairing with. Manual Connection Details . If you cannot utilize automatic discovery (either because it fails or is unavailable), you can also enter manual connection details for Server. To do this, follow the same steps as above (scroll to the bottom of the Interviewer start screen, to the “Server Status” section). Click the white button in the bottom right hand corner (“enter manual connection details”). In the manual connection dialog, you may enter in the IP address and port number of the Server with which you wish to pair. The Server IP address and port number can be found by clicking on the Network Status icon on the top right of the main interface in Server. ",
    "url": "/how-to/pairing/#connecting-to-server",
    "relUrl": "/how-to/pairing/#connecting-to-server"
  },"71": {
    "doc": "Pairing Interviewer Devices with Server",
    "title": "The Pairing Process",
    "content": "Whether you use automatic or manual discovery to locate Server, the pairing process itself will be the same. Once you have attempted to connect to Server, and pairing request will be sent. To accept this request, click the “pair with device” button on the dialog that appears within Server. As soon as you accept the pairing request, a new dialog will open in Server with a unique sixteen letter pairing code. A dialog will then appear in Interviewer on the client device where you will enter the code provided by Server into the sixteen empty fields. Then click the green “pair” button to establish pairing between the devices. Once Interviewer and Server are securely paired, protocols can not be imported from the Server, and Interviewer will enable the “Import from Server” button in the Protocols section. Clicking on “Import From Server” will display any protocols that have been uploaded to Server in the Interviewer client. Selecting one of these protocols from the list will install it. ",
    "url": "/how-to/pairing/#the-pairing-process",
    "relUrl": "/how-to/pairing/#the-pairing-process"
  },"72": {
    "doc": "Pairing Interviewer Devices with Server",
    "title": "Troubleshooting",
    "content": "If you cannot reach Server using automatic or manual discovery following the steps above, please try the following: . | Make sure Server is running. | Ensure both Server and Interviewer are connected to the same local network. If you wish to connect over the internet, ensure you have configured a VPN or similar. | Restart Server and Interviewer on their respective devices. Note: restarting will not drop data. | Contact your network administrator or refer to the details of the error message for further troubleshooting tips. Note: Server uses the Bonjour protocol and requires multicast DNS packets to be able to pass through the network. | As a final step, please contact us by emailing info@networkcanvas.com with details of any error messages you may be receiving. | . ",
    "url": "/how-to/pairing/#troubleshooting",
    "relUrl": "/how-to/pairing/#troubleshooting"
  },"73": {
    "doc": "Pairing Interviewer Devices with Server",
    "title": "Pairing Interviewer Devices with Server",
    "content": " ",
    "url": "/how-to/pairing/",
    "relUrl": "/how-to/pairing/"
  },"74": {
    "doc": "Creating and Managing Workspaces in Server",
    "title": "Creating and Managing Workspaces in Server",
    "content": " ",
    "url": "/how-to/server-workspaces/",
    "relUrl": "/how-to/server-workspaces/"
  },"75": {
    "doc": "Updating from Beta to the Stable Release",
    "title": "Key differences between beta and stable versions",
    "content": "As mentioned, we have made several important changes to the software in the last few months, following feedback and internal discussion. Please note the following key differences between the beta software, and the stable releases. | The “Network Canvas” app is now called “Interviewer”. We wanted a clear name to differentiate the Network Canvas project from the individual survey app itself, and so this seemed like a sensible choice. The app will now appear as “Network Canvas Interviewer” on your devices. | Only boolean variable types can be used as additional variables on prompts. Previously, it was possible to create additional variables on prompts that were of any of the standard Network Canvas types. While this functionality was powerful, it created complicated edge cases that we felt would have been difficult to solve cleanly. Because of this, we decided to only allow boolean variables to be used as additional attributes. Protocols that use the old system will be migrated automatically by the stable version of Architect. | Variable names have stricter rules. Previously there were very few restrictions about the naming you could use for your variables. We realized that this caused difficulties when exporting data, and so now require that variable names conform to the XML NKTOKEN format. In common-sense terms this means that not all characters can be used, variables must not contain spaces, and variables cannot start with certain characters. Protocols using the more permissive variable naming will be automatically upgraded by the stable version of Architect. | The app user interfaces have been significantly redesigned. All three apps in the suite have undergone significant design revisions since the beta period, and while these changes may be confusing at first, we hope you will quickly find them more intuitive. It is important to note that the interview experience for participants is not significantly altered, so we believe that there should be no data quality issues relating to this change. | Data export formats are considerably different. The data export functionality available during the beta contained many eccentricities, and several mistakes that could lead to missing data. The software also lacked a means to export ego-level data reliably. The data export functionality has been completely revamped for the stable release, which required many aspects of the data format to change. Our new formats contain meta data, ego level data, and are more compatible with other software. You will however need to update any data management processes to the new format. | . ",
    "url": "/how-to/updating-from-beta/#key-differences-between-beta-and-stable-versions",
    "relUrl": "/how-to/updating-from-beta/#key-differences-between-beta-and-stable-versions"
  },"76": {
    "doc": "Updating from Beta to the Stable Release",
    "title": "Update process",
    "content": ". | When you are absolutely certain that you have exported all data you require from Network Canvas and Server, and you have your protocol files saved to a location you can remember, please uninstall the existing applications. Windows users who do not know how to uninstall software should consult this Microsoft support article. MacOS users can find the same information in this Apple support article. For iPadOS users, information on removing apps can be found here, and Android users can find information for their devices on this page. | Visit the download page to download the installation packages for the stable version of the software. | (Optional) If you want to continue using a protocol file you have already authored, open it in the stable release of Architect, and it will be automatically upgraded to be compatible with the stable versions of Network Canvas and Server. You may then install it on your device running Interviewer. | (Optional) You can then also use your upgraded protocol in Server, as with previous versions. You will need to re-pair any devices running Interviewer that you wish to use. | . ",
    "url": "/how-to/updating-from-beta/#update-process",
    "relUrl": "/how-to/updating-from-beta/#update-process"
  },"77": {
    "doc": "Updating from Beta to the Stable Release",
    "title": "Troubleshooting",
    "content": ". | If you encounter problems exporting your data from the beta versions of the software, please contact us via email at info@networkcanvas.com. | . ",
    "url": "/how-to/updating-from-beta/#troubleshooting",
    "relUrl": "/how-to/updating-from-beta/#troubleshooting"
  },"78": {
    "doc": "Updating from Beta to the Stable Release",
    "title": "Updating from Beta to the Stable Release",
    "content": "If you are currently using beta versions of our software, you may have seen a notice informing you that they are no longer supported. Going forward, we will only be providing support and updates for the stable versions of our software. This is because we made several important changes that cannot easily be back-ported. In order to avoid inconveniencing you, we made the decision to release these new versions alongside the existing software, and to keep the existing software unchanged, so that you can continue to use it for any in-progress data collection that might be underway. PLEASE NOTE: it will not be possible to migrate data from the beta versions of Server or Network Canvas to the stable versions. Because of this, you should conclude any research and export all the data you require from both Server and Network Canvas before uninstalling the beta versions, and installing the stable versions. Protocols you have authored in Architect can be automatically upgraded by the stable version of Architect to the new format. ",
    "url": "/how-to/updating-from-beta/",
    "relUrl": "/how-to/updating-from-beta/"
  },"79": {
    "doc": "Categorical Bin",
    "title": "Configuring Categorical Bin",
    "content": "An Categorical Bin screen can include multiple prompts, each of which relates to a single categorical variable. Additionally an other variable can be specified for custom responses that don’t fit into the pre-configured categories. Configuring the 'other' variable for a categorical bin prompt ",
    "url": "/interface-documentation/categorical-bin/#configuring-categorical-bin",
    "relUrl": "/interface-documentation/categorical-bin/#configuring-categorical-bin"
  },"80": {
    "doc": "Categorical Bin",
    "title": "Categorical Bin",
    "content": "The Categorical Bin is a name interpreter Interface that collects nominal data on the alters in a participant’s network. When using the Categorical Bin, participants drag and drop alters one-by-one into colorful circles which each represent a category of the categorical variable. Once placed, participants can tap on any category and move alters within that category to any other. ",
    "url": "/interface-documentation/categorical-bin/",
    "relUrl": "/interface-documentation/categorical-bin/"
  },"81": {
    "doc": "Dyad Census",
    "title": "Configuring Dyad Census",
    "content": "A Dyad Census can include multiple prompts, each of which relates to a single edge type. Each alter pair will be considered separately for each prompt. ",
    "url": "/interface-documentation/dyad-census/#configuring-dyad-census",
    "relUrl": "/interface-documentation/dyad-census/#configuring-dyad-census"
  },"82": {
    "doc": "Dyad Census",
    "title": "Dyad Census",
    "content": "The Dyad Census is a name interpreter interface that collects edges for existing alters. On the Dyad Census screen participants are asked if an edge exists for each alter pair combination. This Interface also contains an embedded introductory panel where the purpose of the form can be described to a participant. ",
    "url": "/interface-documentation/dyad-census/",
    "relUrl": "/interface-documentation/dyad-census/"
  },"83": {
    "doc": "Ego Form",
    "title": "Configuring Ego Form",
    "content": "The configurable form determines which variables will be assigned to the ego section of the network. ",
    "url": "/interface-documentation/ego-form/#configuring-ego-form",
    "relUrl": "/interface-documentation/ego-form/#configuring-ego-form"
  },"84": {
    "doc": "Ego Form",
    "title": "Ego Form",
    "content": "The Ego Form is an interface that collects data on your participant (ego). When using the Ego Form, participants complete a form about themselves that consists of one or more fields. This Interface also contains an embedded introductory panel where the purpose of the form can be described to a participant. ",
    "url": "/interface-documentation/ego-form/",
    "relUrl": "/interface-documentation/ego-form/"
  },"85": {
    "doc": "Information",
    "title": "Configuring Information Screen",
    "content": "An information screen is made up of a column of 4 spaces for content. These can be text, images, videos and audio. Items can be re-arranged by dragging. Items can be resized to take up 1, 2 or 4 of the available spaces by dragging from the bottom right corner of the item. Configuring items for a stage based on the Information Interface in Architect ",
    "url": "/interface-documentation/information/#configuring-information-screen",
    "relUrl": "/interface-documentation/information/#configuring-information-screen"
  },"86": {
    "doc": "Information",
    "title": "Information",
    "content": "The Information Interface is a general purpose screen that can be used to present information to participants using a variety of text and media resources. For example, this screen can be useful to introduce a study or to provide instructions or context for a particular stage in the survey. When using the Information Interface, you can incorporate one or multiple resources by either retrieving files from your resource library in Architect or locally from your device. No more than four items can be used at one time. ",
    "url": "/interface-documentation/information/",
    "relUrl": "/interface-documentation/information/"
  },"87": {
    "doc": "Large Roster Name Generator",
    "title": "Defining a Roster",
    "content": "Both of these interfaces require you to have a datafile that represents your roster. See our article on importing roster data for more information about how to create such a file. Have this file, or a suitable mock file, ready before you attempt to configure either of these interfaces. We have tested a 60,000 node roster in the Large Roster Name Generator with success, however, rosters of this size are not without problems. If your study requires such a roster, please be prepared for the loading and search functions to slow down considerably. The upper limit of this interface is largely dependent on both the device you use and your usability threshold, so a powerful laptop might be required particularly for larger datasets. For information on devices, please see our article on choosing a device for your study. ",
    "url": "/interface-documentation/large-roster-name-generator/#defining-a-roster",
    "relUrl": "/interface-documentation/large-roster-name-generator/#defining-a-roster"
  },"88": {
    "doc": "Large Roster Name Generator",
    "title": "Large Roster Name Generator",
    "content": "The Large Roster Name Generator, as the name implies, has been designed specifically around significantly larger datasets. If your roster contains over 100 nodes, you should consider if the Large Roster Name Generator will provide a better user experience for your participants. Nominating an alter within this interfaces uses the following process: . | The primary action button triggers a search box, into which a participant can type to search for nodes based on the search options (see below) you have configured. | As the participant begins typing, all node data that meets the criteria will be displayed as cards above the search box. | The participant may then tap (or click) one or more cards, to nominate them. As this happens, a node button with a plus icon will appear on the right edge of the search panel, and the number will increment as each card is selected. | Any nominated nodes will not be added to the interview until the plus button is clicked. Multiple searches can be completed with the search panel still open, meaning the participant does not need to click the plus button after each search - merely when they feel they have finished the task. | . By default, the cards will display the name attribute from the roster data as the card title. As with the Small Roster Name Generator, the display options of these cards are completely configurable. You should display all attributes that a participant might need to disambiguate roster nodes with similar names. The search function is also heavily configurable, allowing you to choose which attributes from the roster are indexed, as well as the accuracy (or ‘fuzziness’) of the search matching. These options are powerful, and should be configured carefully. Each attribute added to the searchable properties list will decrease the performance of the search function, and may make matches less accurate. Similarly, using too stringent or too lax search accuracy will compromise the ability of participants to locate nodes in the roster. As a general rule of thumb search accuracy should increase as roster size increases, and only attributes containing terms participants are likely to search by should be included as indexed attributes. ",
    "url": "/interface-documentation/large-roster-name-generator/#large-roster-name-generator",
    "relUrl": "/interface-documentation/large-roster-name-generator/#large-roster-name-generator"
  },"89": {
    "doc": "Large Roster Name Generator",
    "title": "Large Roster Name Generator",
    "content": "Name Generators are one of the fundamental components of a network interview. They allow your participant to create alters, thereby describing one of the two main entities in your study’s networks. There are four name generator Interfaces in Network Canvas that can be added to your study, all of which can be configured within Architect. Each of these Interfaces is designed for a specific type of alter elicitation, with several associated advantages and disadvantages. Although they have some configuration options that are shared with all other Network Canvas Interfaces, this article will focus on options specific to roster based name generators. Roster name generators are useful when you have a known set of network members that you want your participant to be able to nominate. The “Small Roster Name Generator” and the “Large Roster Name Generator” Interfaces differ in two crucial ways: . | The size of the roster data they are designed to work with. | The method of nominating a member of the roster to be brought into the interview network. | . ",
    "url": "/interface-documentation/large-roster-name-generator/",
    "relUrl": "/interface-documentation/large-roster-name-generator/"
  },"90": {
    "doc": "Name Generator using Forms",
    "title": "Shared Interface Elements",
    "content": "Both the “Name Generator (Using Forms)” and the “Name Generator (Quick Add)” Interfaces share some common visual elements. The prompt area, where the task is explained to the participant (see: prompts), a node list area where alters that have been elicited are displayed, a primary action button that triggers the node elicitation process, and (optionally) one or more Side Panels. Beyond this, you have a choice about how precisely alters should be created - either using a full featured form, or using a simple “quick add” method. Side Panels . Both of these name generators can use Side Panels. Side panels are a powerful feature that allows you to use network data from either the in-progress interview or from a network data file uploaded to your Architect resource library to assist with name generation activities. For example, when multiple prompts within a name generator have potential overlap in a participant’s social network, it may be useful to bring nodes previously nominated onto a subsequent screen so that a participant can easily list them again. Configuring a side panel A side panel can also be created using a network data file (e.g. a roster) to allow a participant to select and nominate alters from a predetermined list. It is important to note that the exact same list will appear on subsequent side panels within the name generator unless a rule(s) is created to filter the data to be shown on the panel (see network filtering). Side panels can be expanded or contracted in the interview by clicking on the heading. ",
    "url": "/interface-documentation/name-generator-using-forms/#shared-interface-elements",
    "relUrl": "/interface-documentation/name-generator-using-forms/#shared-interface-elements"
  },"91": {
    "doc": "Name Generator using Forms",
    "title": "Using Forms",
    "content": "When using the “Name Generator (using forms)” Interface, the primary action button will trigger a form that participants must complete to create an alter. This form can include one or more fields to capture specific attribute data on each node (see our key concepts article on forms for further information on creating a form). This interface therefore combines the process of generating alters with the ability to do some basic attribute collection, or name interpreting, tasks. An example form ",
    "url": "/interface-documentation/name-generator-using-forms/#using-forms",
    "relUrl": "/interface-documentation/name-generator-using-forms/#using-forms"
  },"92": {
    "doc": "Name Generator using Forms",
    "title": "Name Generator using Forms",
    "content": "Name Generators are one of the fundamental components of a network interview. They allow your participant to create alters, thereby describing one of the two main entities in your study’s networks. There are four name generator Interfaces in Network Canvas that can be added to your study, all of which can be configured within Architect. Available Name Generator interfaces in Architect Each of these Interfaces is designed for a specific type of alter elicitation, with several associated advantages and disadvantages. Although they have some configuration options that are shared with all other Network Canvas Interfaces, this article will focus on options specific to the main name generator interface, and a variant of it that uses a ‘quick add’ mode. Using roster data in your study? Refer to our documentation on the small roster name generator or large roster name generator. ",
    "url": "/interface-documentation/name-generator-using-forms/",
    "relUrl": "/interface-documentation/name-generator-using-forms/"
  },"93": {
    "doc": "Name Generators using Quick Add",
    "title": "Shared Interface Elements",
    "content": "Both the “Name Generator (Using Forms)” and the “Name Generator (Quick Add)” Interfaces share some common visual elements. The prompt area, where the task is explained to the participant (see: prompts), a node list area where alters that have been elicited are displayed, a primary action button that triggers the node elicitation process, and (optionally) one or more Side Panels. Beyond this, you have a choice about how precisely alters should be created - either using a full featured form, or using a simple “quick add” method. Side Panels . Both of these name generators can use Side Panels. Side panels are a powerful feature that allows you to use network data from either the in-progress interview or from a network data file uploaded to your Architect resource library to assist with name generation activities. For example, when multiple prompts within a name generator have potential overlap in a participant’s social network, it may be useful to bring nodes previously nominated onto a subsequent screen so that a participant can easily list them again. Configuring a side panel A side panel can also be created using a network data file (e.g. a roster) to allow a participant to select and nominate alters from a predetermined list. It is important to note that the exact same list will appear on subsequent side panels within the name generator unless a rule(s) is created to filter the data to be shown on the panel (see network filtering). Side panels can be expanded or contracted in the interview by clicking on the heading. ",
    "url": "/interface-documentation/name-generator-using-quick-add/#shared-interface-elements",
    "relUrl": "/interface-documentation/name-generator-using-quick-add/#shared-interface-elements"
  },"94": {
    "doc": "Name Generators using Quick Add",
    "title": "Using “Quick Add”",
    "content": "When using the “Name Generator (using quick add)” Interface, the primary action button will trigger a single field form that a participant must complete to create an alter. This Interface uses a single “quick add variable” to store the value of the form, which allows a participant to rapidly create alters. A quick add name generator One or multiple additional variables can be added to alters nominated on this Interface. Capturing additional variables may be useful either to help track where a node was elicited or to reflect a name interpreter element of the prompt (e.g. adding a variable called “close_friend” to a prompt asking about closeness). ",
    "url": "/interface-documentation/name-generator-using-quick-add/#using-quick-add",
    "relUrl": "/interface-documentation/name-generator-using-quick-add/#using-quick-add"
  },"95": {
    "doc": "Name Generators using Quick Add",
    "title": "Name Generators using Quick Add",
    "content": "Name Generators are one of the fundamental components of a network interview. They allow your participant to create alters, thereby describing one of the two main entities in your study’s networks. There are four name generator Interfaces in Network Canvas that can be added to your study, all of which can be configured within Architect. Available Name Generator interfaces in Architect Each of these Interfaces is designed for a specific type of alter elicitation, with several associated advantages and disadvantages. Although they have some configuration options that are shared with all other Network Canvas Interfaces, this article will focus on options specific to the main name generator interface, and a variant of it that uses a ‘quick add’ mode. Using roster data in your study? Refer to our documentation on the small roster name generator or large roster name generator. ",
    "url": "/interface-documentation/name-generator-using-quick-add/",
    "relUrl": "/interface-documentation/name-generator-using-quick-add/"
  },"96": {
    "doc": "Narrative",
    "title": "The Narrative Interface",
    "content": "On the “Narrative” Interface, alter edges, group and individual attribute variables can be displayed to elicit qualitative data from the participant about their network. Configured presets can be toggled on and off to reveal colored convex hulls representing group variables, highlighted nodes representing attribute data, and different edge types in the network. No data is collected on this Interface. ",
    "url": "/interface-documentation/narrative/#the-narrative-interface",
    "relUrl": "/interface-documentation/narrative/#the-narrative-interface"
  },"97": {
    "doc": "Narrative",
    "title": "Narrative",
    "content": "Sociograms are the visual mapping component of a network interview. On the Sociogram, participants draw ties between alters to signify the relationships between individuals within their personal network. There are two sociogram Interfaces in Network Canvas - one for data collection and one for data display - that can be added to your study and configured in Architect. ",
    "url": "/interface-documentation/narrative/",
    "relUrl": "/interface-documentation/narrative/"
  },"98": {
    "doc": "Ordinal Bin",
    "title": "Configuring Ordinal Bin",
    "content": "A single node type is selectable per screen. This screen supports filtering those nodes by their attributes. An Ordinal Bin screen can include multiple prompts, each of which relates to a single ordinal variable. ",
    "url": "/interface-documentation/ordinal-bin/#configuring-ordinal-bin",
    "relUrl": "/interface-documentation/ordinal-bin/#configuring-ordinal-bin"
  },"99": {
    "doc": "Ordinal Bin",
    "title": "Ordinal Bin",
    "content": "The Ordinal Bin is a name interpreter Interface that captures ordinal data on the alters in a participant’s network. When using the Ordinal Bin, participants drag and drop alters one-by-one into parallel bins denoting values on an ordinal scale. Once placed, participants can move alters from one bin to another. ",
    "url": "/interface-documentation/ordinal-bin/",
    "relUrl": "/interface-documentation/ordinal-bin/"
  },"100": {
    "doc": "Per Alter Edge Form",
    "title": "Configuring Per Alter Edge Form",
    "content": "A single edge type is selectable per screen. This screen supports filtering for edges that match the specified type. The introduction screen is shown before any matching edges and can be used to introduce the task. Each edge will be assigned variables using a configurable form. Form fields can be re-ordered by dragging, and deleted by clicking the right hand 'x' ",
    "url": "/interface-documentation/per-alter-edge-form/#configuring-per-alter-edge-form",
    "relUrl": "/interface-documentation/per-alter-edge-form/#configuring-per-alter-edge-form"
  },"101": {
    "doc": "Per Alter Edge Form",
    "title": "Per Alter Edge Form",
    "content": "The Per Alter Edge Form is an edge interpreter interface that collects attribute data on the edges, or relationships, between nodes in a participant’s network. When using the Per Alter Edge Form, participants review an introductory screen that describes the tasks on the stage and then complete a form for each edge they previously defined between pairs of alters within their network. These forms are customizable and can include one or multiple fields to collect specific edge attribute data. ",
    "url": "/interface-documentation/per-alter-edge-form/",
    "relUrl": "/interface-documentation/per-alter-edge-form/"
  },"102": {
    "doc": "Per Alter Form",
    "title": "Configuring Per Alter Form",
    "content": ". A single edge type is selectable per screen. This screen supports filtering for nodes that match the specified type. The introduction screen is shown before any matching alters and can be used to introduce the task. Each node will be assigned variables using a configurable form. ",
    "url": "/interface-documentation/per-alter-form/#configuring-per-alter-form",
    "relUrl": "/interface-documentation/per-alter-form/#configuring-per-alter-form"
  },"103": {
    "doc": "Per Alter Form",
    "title": "Per Alter Form",
    "content": "The Per Alter Form is a name interpreter interface that captures attribute data on the alters in a participant’s network. When using the Per Alter Form, participants review an introductory panel which describes the tasks on the stage and then complete a form on each node in their network. These forms are customizable and can include one or multiple fields to collect specific attribute data using a variety of input controls. ",
    "url": "/interface-documentation/per-alter-form/",
    "relUrl": "/interface-documentation/per-alter-form/"
  },"104": {
    "doc": "Shared Interface Options",
    "title": "Shared Configuration",
    "content": ". Name . All stages have a configurable name. This is shown in the navigation when conducting interviews, and in the timeline when constructing interviews. It can be used to set a memorable title or describe the purpose of a particular stage. Entity Type . All stage types must select a single entity type, which defines the primary entity type for data collection. The one exception is the information screen, which does not collect any data. Depending on the specific interface this will refer to either a node type, or an edge type. Filtering . This feature is available to Sociogram and Name Interpreter stage type categories. It allows further refinement of the selected entity type. For example, a Sociogram may have a “Person” node type selected as the entity type. You may then use this option to narrow down to only those “Person” nodes which also have a specific attribute. Find out more about filtering . Skip Logic . This feature is available to all stage types. The state of the participant network may be assessed in order to determine whether a stage should be shown or instead skipped. Find out more about skip logic . ",
    "url": "/interface-documentation/shared/#shared-configuration",
    "relUrl": "/interface-documentation/shared/#shared-configuration"
  },"105": {
    "doc": "Shared Interface Options",
    "title": "Shared Interface Options",
    "content": "Some configuration options are available to all or most interface screens (dependent on the sub-category of interface, e.g. name generators). ",
    "url": "/interface-documentation/shared/",
    "relUrl": "/interface-documentation/shared/"
  },"106": {
    "doc": "Small Roster Name Generator",
    "title": "Defining a Roster",
    "content": "Both of these interfaces require you to have a datafile that represents your roster. See our article on importing roster data for more information about how to create such a file. Have this file, or a suitable mock file, ready before you attempt to configure either of these interfaces. We have tested a 60,000 node roster in the Large Roster Name Generator with success, however, rosters of this size are not without problems. If your study requires such a roster, please be prepared for the loading and search functions to slow down considerably. The upper limit of this interface is largely dependent on both the device you use and your usability threshold, so a powerful laptop might be required particularly for larger datasets. For information on devices, please see our article on choosing a device for your study. ",
    "url": "/interface-documentation/small-roster-name-generator/#defining-a-roster",
    "relUrl": "/interface-documentation/small-roster-name-generator/#defining-a-roster"
  },"107": {
    "doc": "Small Roster Name Generator",
    "title": "Small Roster Name Generator",
    "content": "When using the “Small Roster Name Generator” Interface, cards representing node data from a predetermined roster will be displayed to a participant. This Interface is intended to accommodate roster data files containing up to 100 nodes, with the idea that the list view allows for simple and fast scanning of the roster by a participant, supported by sorting and filtering where necessary. By default, cards will display the name attribute from the roster data as a card title, and will sort the cards in the order the nodes are defined in the data file. These options can be configured from within architect. Note that you are able to define both the default sorting options, and allow the user to sort themselves by multiple properties. ",
    "url": "/interface-documentation/small-roster-name-generator/#small-roster-name-generator",
    "relUrl": "/interface-documentation/small-roster-name-generator/#small-roster-name-generator"
  },"108": {
    "doc": "Small Roster Name Generator",
    "title": "Small Roster Name Generator",
    "content": "Name Generators are one of the fundamental components of a network interview. They allow your participant to create alters, thereby describing one of the two main entities in your study’s networks. There are four name generator Interfaces in Network Canvas that can be added to your study, all of which can be configured within Architect. Each of these Interfaces is designed for a specific type of alter elicitation, with several associated advantages and disadvantages. Although they have some configuration options that are shared with all other Network Canvas Interfaces, this article will focus on options specific to roster based name generators. Roster name generators are useful when you have a known set of network members that you want your participant to be able to nominate. The “Small Roster Name Generator” and the “Large Roster Name Generator” Interfaces differ in two crucial ways: . | The size of the roster data they are designed to work with. | The method of nominating a member of the roster to be brought into the interview network. | . ",
    "url": "/interface-documentation/small-roster-name-generator/",
    "relUrl": "/interface-documentation/small-roster-name-generator/"
  },"109": {
    "doc": "Sociogram",
    "title": "Sociogram",
    "content": "When using the “Sociogram” Interface, participants position their alters and draw ties between them. The Interface can be used to create one or multiple edge types between alters in a participant’s network, and to collect alter attribute data by highlighting alters where the variable value is true. ",
    "url": "/interface-documentation/sociogram/#sociogram",
    "relUrl": "/interface-documentation/sociogram/#sociogram"
  },"110": {
    "doc": "Sociogram",
    "title": "Sociogram",
    "content": "Sociograms are the visual mapping component of a network interview. On the Sociogram, participants draw ties between alters to signify the relationships between individuals within their personal network. There are two sociogram Interfaces in Network Canvas - one for data collection and one for data display - that can be added to your study and configured in Architect. ",
    "url": "/interface-documentation/sociogram/",
    "relUrl": "/interface-documentation/sociogram/"
  },"111": {
    "doc": "Tie-Strength Census",
    "title": "Tie-Strength Census",
    "content": "The Tie-Strength Census interface is similar to the Dyad Census in terms of user experience, but has the additional benefit of assigning an ordinal variable value to each edge that is created. For each pair of alters, the participant will be able to indicate if a tie is present by indicating the strength of that tie. The participant can also indicate that a tie is not present between the pair. Selecting an option will automatically advance to the next pair, creating a stremlined and low-burden experience. If your interview uses the dyad census method (as opposed to creating edges using the Sociogram interface) and you are also interested in tie strength, consider using this interface to reduce the response burden on your participants. To configure this interface in Architect, you will first determine the node type for which edges will be created. Next you will configure one or more prompts, with each prompt specifying: . | An edge type that will be created | An ordinal variable that will receive a value when an edge is confirmed. This ordinal variable will be created on the edge type you specified. | A label to be used for the option that indicates that no tie is present | . ",
    "url": "/interface-documentation/tie-strength-census/",
    "relUrl": "/interface-documentation/tie-strength-census/"
  },"112": {
    "doc": "Additional Variables",
    "title": "Additional Variables",
    "content": "“Additional variables” are defined on individual prompts in Name Generator stages and automatically assigned to any entity that is active on that given prompt. These variables are optional, and can be used to keep track of where within an interview an entity was used, or to add to an element. Additional variables are boolean values, either “true” or “false”. These variables can then be used in skip logic or filtering rules. Managing additional variables on a Name Generator prompt in Architect In Architect, on a Name Generator stage, you can add one or more additional variable to a prompt. You can create new variables or reuse other variables, and specify whether a prompt toggles the variable to “true” or “false”. In an interview, additional variables are toggled when nodes are added or removed from a prompt, with no required effort from the user. ",
    "url": "/key-concepts/additional-variables/",
    "relUrl": "/key-concepts/additional-variables/"
  },"113": {
    "doc": "Codebook",
    "title": "Entity Types",
    "content": "The codebook organizes entities by entity type – Ego, Node, and Edge, and organizes variables by entity. Node and edge types can be edited from the codebook using the “Edit Entity” button. Each node and edge type lists the stages that they are used on, and you can navigate to those stages by clicking on one of the “used in” stage names. A view of codebook in Architect. ",
    "url": "/key-concepts/codebook/#entity-types",
    "relUrl": "/key-concepts/codebook/#entity-types"
  },"114": {
    "doc": "Codebook",
    "title": "Variables",
    "content": "Each variable lists the name, type, input control, and where it is used. You can navigate to any of the stages a variable is used in by clicking on one of the “used in” stage names just like the entity types. Entity types and variables both indicate which stages they are used in. If a variable is defined but later becomes obsolete, you can see this as an unused variable within the codebook, marked “not in use”. Only variables that are unused can be deleted from the codebook. Entity types can also only be deleted if they are unsused in the protocol. Variables marked 'not in use' and unused entity types can be deleted in the codebook view. ",
    "url": "/key-concepts/codebook/#variables",
    "relUrl": "/key-concepts/codebook/#variables"
  },"115": {
    "doc": "Codebook",
    "title": "Network Assets",
    "content": "Codebooks also contain a summary of Network Assets when external network data has been included in a protocol. The heading row of network data will be used as the variable names, and codebook lists these variable names as a summary for each external network asset. A summary of the variables from an external network file. ",
    "url": "/key-concepts/codebook/#network-assets",
    "relUrl": "/key-concepts/codebook/#network-assets"
  },"116": {
    "doc": "Codebook",
    "title": "Codebook",
    "content": "The protocol’s codebook gives an overview of the entities and variables defined for the protocol. Architect automatically constructs the codebook as you create variables in a protocol. The codebook can be visualized in the codebook view. To access the codebook in Architect, click on the “Manage codebook” button at the top of a protocol file. Clicking the 'Manage codebook' button in Architect will navigate to the codebook view ",
    "url": "/key-concepts/codebook/",
    "relUrl": "/key-concepts/codebook/"
  },"117": {
    "doc": "Field Validation",
    "title": "Field Validation",
    "content": "Configuring validation refers to the process of setting constraints on the answers a participant can give in response to question prompts within a form. One or multiple validations can be configured for each field of a form depending on the needs of the particular study, but none appear by default. Setting validations on particular question prompts may help improve your data quality by minimizing extraneous and missing answers from participants. For example, if you plan to only survey participants between the ages of 18 and 24, you may want to set a validation on an Ego Form that constrains the minValue and maxValue of a participant’s answer to a question prompt asking for their age. Similarly, you may wish to require participants to provide a name for each node they nominate on a Name Generator using forms. If a validation has been set and a participant’s response to the question prompt does not comply with the constraints, Interviewer will indicate the error. Validation options differ depending on the input control used to capture the variable in question. You can view all Interviewer input controls and corresponding validations in the input controls article. ",
    "url": "/key-concepts/field-validation/",
    "relUrl": "/key-concepts/field-validation/"
  },"118": {
    "doc": "Forms",
    "title": "Constructing a Form",
    "content": "Forms are comprised of one or more ‘fields’, which can be re-ordered to appear in any sequence. The sequence they appear in Architect is the same sequence that they will be shown in Interviewer. To begin creating a form, locate the form section within the interface you are configuring. Set the form heading, and then create fields for each of the variables you wish to capture on this form, by clicking the “create new” button. When creating a new field, you will first either create a new variable or select an existing one to use from the variable chooser. Next, you will type the question prompt to be shown next to the input control. Next you must decide which input control to use, which for new variables will determine the type that this variable will be set to. Remember that once a variable type has been set, such as by choosing its input type when it is first used, it cannot be changed later. You may still adjust the specific input control on your form even once the type is set, as long as the input control is compatible with the variable type. After setting the input control, set any variable specific options and configure the validation options you require. ",
    "url": "/key-concepts/forms/#constructing-a-form",
    "relUrl": "/key-concepts/forms/#constructing-a-form"
  },"119": {
    "doc": "Forms",
    "title": "Considerations",
    "content": "When designing forms, there are a few things that you should keep in mind: . | Although it may be tempting to create long and elaborate forms, as is typical within other more traditional survey software, we encourage researchers to consider the burden of overloaded forms on participants and data quality. For example, while it is possible to capture categorical data within a form, you might elect to use the Categorical Bin interface instead. Network Canvas Interviewer is not intended to replace existing survey methods. | Making strategic use of forms allows you to capture attribute data systematically, however, you lose the interactive qualities (e.g. dragging and dropping) of other interfaces that may improve the interview experience for participants and potentially render higher quality data. | If you use the same variable in multiple places in your interview (for example in different forms), any changes you make to the input control or validation options will apply to all uses of the variable. | . ",
    "url": "/key-concepts/forms/#considerations",
    "relUrl": "/key-concepts/forms/#considerations"
  },"120": {
    "doc": "Forms",
    "title": "Forms",
    "content": "Forms are one of the primary ways that that you will assign values to your variables in Interviewer. They work by associating each variable with an input control, a question prompt and validation options, to form a field. Each form can have as many fields as you wish, and in any order. When using Architect to design your study you will encounter several places where you are able to build a form - particularly when creating stages that use Interfaces such as the Name Generator, the Per-alter Form, and the Ego Form. ",
    "url": "/key-concepts/forms/",
    "relUrl": "/key-concepts/forms/"
  },"121": {
    "doc": "Input Controls",
    "title": "Checkbox Group",
    "content": ". Purpose . The checkbox group is designed to provide a familiar interface for selecting one or more items from a (non-hierarchical) range of options. Options are displayed vertically, to allow for longer labels and to create a more scannable list. Horizontal checkbox groups are not supported. Good practices . | Use this input control for allowing the participant to select multiple items. | Check that the option labels are not too long, or text wrapping might be an issue. | Use validation options to set the maximum and minimum number of options that the participant can select. | Keep option labels concise, and make them easily differentiated from one another. | Consider the order of your options, and the impact order bias might have on your data. | . Things to avoid . | Do not use more than 8 options, unless absolutely necessary. Long checkbox groups can be hard to see on a screen without scrolling. | Avoid using this control when the data is hierarchical, or when the participant should only select a single option. Use the RadioGroup or the Likert scale instead. | . ",
    "url": "/key-concepts/input-controls/#checkbox-group",
    "relUrl": "/key-concepts/input-controls/#checkbox-group"
  },"122": {
    "doc": "Input Controls",
    "title": "Date Picker",
    "content": ". Purpose . The date picker input control is used to select a date with various levels of specificity. By default the resolution of the data picker is set to “year/month/day”, but you can also set it to be less granular, thereby allowing participants to select a year and month or simply a year. If your interview context is better suited to keyboard text entry rather than the use of a touch screen, consider using a standard text input as this may be faster. Good practices . | Carefully consider the range of values that you allow your participant to select between. You should aim to constrain these values as much as possible, to eliminate potential errors. | For questions asking about the past, make use of the ability to specify an empty “end range” parameter, which will ensure that the most recent date the participant can select is aligned with the date of the interview. | Use the resolution parameter to only collect data to an appropriate level of specificity. It is often better to collect data at a lower resolution with more certainty, than a higher resolution with more error. | . Things to avoid . | Since dates can be burdensome to enter, avoid the use of this control in name generator forms. | Since this control is optimized for touch/mouse, avoid using it if you are creating a largely keyboard driven interview. | . ",
    "url": "/key-concepts/input-controls/#date-picker",
    "relUrl": "/key-concepts/input-controls/#date-picker"
  },"123": {
    "doc": "Input Controls",
    "title": "Likert Scale",
    "content": ". Purpose . The Likert scale control allows participants to select from an ordered series of options. Likert scales are widely used in psychometric research. Typically they have five ordered categories, such as “Strongly disagree”, “Disagree”, “Neither agree nor disagree”, “Agree”, and “Strongly Agree”. When used in Network Canvas, you can select the number and value of the response categories to suit your needs. When first loaded, this control is in an “untouched” state, with a semi-transparent draggable handle positioned on the left. Please note that in this state no value will be assigned to the variable. The participant must interact with the handle, even if it is to simply move it back into its initial position, in order for a value to be stored. To ensure that no values are missed, consider setting the required validation option. Good practices . | Consider whether you want to provide a middle choice or not and mark it as neutral/ambivalent (e.g., “neither agree nor disagree”, rather than unsure). | Consider whether you need more than five categories. Much research suggests there’s limited power in using seven or more categories rather than just 5 (or even 3). | Note the special way this control handles the ‘required’ validation - no value will be recorded in the variable until the participant has interacted with the control. Once interacted with, the value of the control cannot be unset. | . Things to avoid . | Never place the response categories out of order - they must be in sequence. | Do not use this control for large numbers of options. Consider the use of the RadioGroup control instead. | . ",
    "url": "/key-concepts/input-controls/#likert-scale",
    "relUrl": "/key-concepts/input-controls/#likert-scale"
  },"124": {
    "doc": "Input Controls",
    "title": "Number Input",
    "content": ". Purpose . A number input is a control that provides a simple box for integer data collection. Integers can be entered with a keyboard or, if available, a number pad will appear. Please note that because of the way numbers are represented scientifically, the character ‘e’ is considered valid within this input. Good practices . | Set validation options that constrain the range of possible entries when the variable value should only be positive (e.g. age). | Use this control for capturing numeric data rather than the text input for cleaner data. | . Things to avoid . | Do not use the number input to capture date data. Date data should be captured using the DatePicker or a text input. | Do not use this control for non-integer number variables, such as phone numbers. Use a text input. | . ",
    "url": "/key-concepts/input-controls/#number-input",
    "relUrl": "/key-concepts/input-controls/#number-input"
  },"125": {
    "doc": "Input Controls",
    "title": "Radio Group",
    "content": ". Purpose . A radio group is a control that allows participants to select a single choice from a group of (potentially hierarchical) options. The options are displayed to the participant vertically, to allow for longer labels and to create a more scannable list. Good practices . | Create succinct labels for options to avoid issues with text wrapping. | Ensure that option labels can be quickly differentiated from one another. | Carefully consider the ordering of your options. Even if your options are not hierarchical, ordering may bias your data in other ways. | Use this control when only one item should be selected. | . Things to avoid . | Avoid using long radio groups with many options, as they can be difficult for a participant to see without scrolling. | Items that are not selected provide an ‘implied no’, meaning that all items not selected by a participant do not apply to them. If you need explicit confirmation, consider using a different input control with a true/false value per option. | If a participant should be able to toggle multiple items for the variable in question, consider using the checkbox group or toggle box group instead. | . ",
    "url": "/key-concepts/input-controls/#radio-group",
    "relUrl": "/key-concepts/input-controls/#radio-group"
  },"126": {
    "doc": "Input Controls",
    "title": "Relative Date Picker",
    "content": ". Purpose . The relative date picker is a control that provides a calendar date picker which automatically limits available dates relative to an “anchor date.” An anchor date can be manually specified, or the control can be configured to automatically use the date of the interview session. This control is particularly useful for scenarios where you are concerned with events that have happened (or will happen) within a known amount of time relative to another date. For example, “within the past 6 months, when was the last time you saw this person?”, or “Do you have an appointment for a test at this clinic within the next 30 days? If so, please indicate the date”. Unlike the date picker control, the relative date picker does not allow you to set the resolution of the data collected. Good practices . | Ensure you specify the range of dates prior to or after the anchor date to broaden or shorten available dates a participant can select from. By default, the relative date picker uses 180 days prior to and 0 days after the anchor date. | . Things to avoid . | If you want to allow participants to be less granular in their date selection, such as just using a month or a year rather than a date, consider using the date picker control instead. | . ",
    "url": "/key-concepts/input-controls/#relative-date-picker",
    "relUrl": "/key-concepts/input-controls/#relative-date-picker"
  },"127": {
    "doc": "Input Controls",
    "title": "Text Area",
    "content": ". Purpose . The text area control provides participants with a simple field for data entry of more than 30 characters. Good practices . | Use the text area control for question prompts that require longer form responses from participants. This may be especially useful for qualitative studies. | . Things to avoid . | Avoid using a text area control when the data you want could be more effectively captured as a categorical or numeric variable. | Avoid using the text area control on devices with software keyboards, since text entry can be error-prone and laborious. | . ",
    "url": "/key-concepts/input-controls/#text-area",
    "relUrl": "/key-concepts/input-controls/#text-area"
  },"128": {
    "doc": "Input Controls",
    "title": "Text Input",
    "content": ". Purpose . The text input control provides participants with a field for simple data entry of up to approximately 30 characters. Good practices . | Set correct validation options to ensure that appropriate data is provided. | Consider using the text input control for numerical data that should be stored as a string, such as phone numbers. | Ensure the prompt for the question is clear so that the data entered into the text input requires less cleaning. | . Things to avoid . | Do not use the text input control for longer responses, or free form data. Use the text area control instead. | It is not possible to paste text into the text input control. Do not rely on pasting data into this control. | . ",
    "url": "/key-concepts/input-controls/#text-input",
    "relUrl": "/key-concepts/input-controls/#text-input"
  },"129": {
    "doc": "Input Controls",
    "title": "Toggle",
    "content": ". Purpose . The toggle control provides participants a switch that can be toggled on or off, and is designed to model boolean data. By default, the switch begins in the “off” position. Good practices . | Use a toggle to easily collect simple true/false variable values, and specifically to indicate the presence of an attribute. | Consider using multiple toggles to indicate attributes that can then be used as part of network filtering or skip logic. | . Things to avoid . | Only use the toggle for dichotomous variables. Where a third option is required, consider using a radio group instead. | Carefully consider the ‘implied no’ inherent in this input control. If you require the user to specifically indicate a negative value, consider using a RadioGroup with two items, and using the required validation. | . ",
    "url": "/key-concepts/input-controls/#toggle",
    "relUrl": "/key-concepts/input-controls/#toggle"
  },"130": {
    "doc": "Input Controls",
    "title": "Toggle Button Group",
    "content": ". Purpose . The toggle button group is a control for non-hierarchical categorical variables that displays colorful circles that can be toggled on or off, and allows for multiple selection. It is provided as an alternative to the checkbox group for scenarios where it may be more intuitive or visually engaging for your participants. Good practices . | Use this component to collect categorical data, particularly when you have smaller numbers of items. | The visual emphasis of this control implies ‘membership’, so consider using it for variables that represent groups or activities. | . Things to avoid . | Avoid using long labels, or labels of more than two words, as it may be difficult for participants to clearly see the categories. | Avoid using more than 8 categories for a toggle button group, as only 8 distinct colors are provided. | . ",
    "url": "/key-concepts/input-controls/#toggle-button-group",
    "relUrl": "/key-concepts/input-controls/#toggle-button-group"
  },"131": {
    "doc": "Input Controls",
    "title": "Visual Analog Scale",
    "content": ". Purpose . A visual analog scale is a control that sets a normalized value between 0 and 1 represented by the position of a slider between each end of a scale. Good practices . | Consider using a visual analog scale to collect variable data that is best represented on a continuum with a linear progression. Participants are able to give more precise responses on a continuum rather choose a specific option, like on a Likert scale. | . Things to avoid . | Use another control for variables necessitating multiple predefined items. | . ",
    "url": "/key-concepts/input-controls/#visual-analog-scale",
    "relUrl": "/key-concepts/input-controls/#visual-analog-scale"
  },"132": {
    "doc": "Input Controls",
    "title": "Input Controls",
    "content": "Below you will find a summary of each available input control, and advice about when to use them. ",
    "url": "/key-concepts/input-controls/",
    "relUrl": "/key-concepts/input-controls/"
  },"133": {
    "doc": "Interfaces",
    "title": "Types of Interfaces",
    "content": "Interfaces can be broadly categorized as: name generators, edge generators, name interpreters, edge interpreters, or utilities. Name Generator Interfaces . Name Generators allow participants to create alters during the course of an interview, thereby describing one of the two main entities in your study’s networks. There are four possible Name Generators available to select from, each designed for specific scenarios: Name Generator (using forms), Name Generator (using quick add), Small Roster Name Generator, or Large Roster Name Generator. Available Name Generator Interfaces in Architect Sociogram Interfaces . Sociograms are the visual mapping component of a network interview. On the Sociogram, participants draw ties between alters to signify the relationships between individuals within their personal network, describing the other main entity in your study’s networks. There are two sociogram Interfaces in Network Canvas - one for data collection (Sociogram) and one for data display (Narrative) - that can be added to your study and configured in Architect. Available Sociogram Interfaces in Architect Name Interpreter Interfaces . Once a study contains entities, Name Interpreter Interfaces can be used to collect additional information and build upon the existing alters or ties. These interfaces include: Ordinal Bin, Categorical Bin, Per Alter Form, Per Alter Edge Form, Ego Form, and Dyad Census. Available Name Interpreter Interfaces in Architect Utility Interfaces . The Information Interface is a general purpose screen that can be used to present information to participants using a variety of text and media resources. This is helpful in explaining stage functionalities and increasing participant comprehension. Available Utility Interfaces in Architect ",
    "url": "/key-concepts/interfaces/#types-of-interfaces",
    "relUrl": "/key-concepts/interfaces/#types-of-interfaces"
  },"134": {
    "doc": "Interfaces",
    "title": "Interfaces",
    "content": "Interviews in Network Canvas are comprised of one or more ‘stages’, which can be thought of as the individual screens that a participant sees. Each stage is an instance of an ‘Interface’, which has been configured to collect specific variables, or create nodes/edges. Interfaces are therefore the most fundamental building blocks of a Network Canvas interview. Each Interface is designed to accomplish a single specific task in the network interview. Some tasks, such as edge generation, can be accomplished with different interfaces. Which interface you choose when designing your interview in Architect is entirely up to you. ",
    "url": "/key-concepts/interfaces/",
    "relUrl": "/key-concepts/interfaces/"
  },"135": {
    "doc": "Network Filtering",
    "title": "Configuring Network Filtering on a Stage",
    "content": "To configure network filtering within a stage, open the stage from the timeline view, and toggle the switch to enable “Network Filtering”. From here, you have the ability to create one or more rules (of type alter or edge), as well as to set the join operator by determining if “all rules”, or “any rule” must match. Network filtering is only available on name interpreter interfaces - interfaces that add attributes to nodes or edges. It is not available on specialist name generator interfaces. Filtering Rules . Similar to skip logic rules, filtering rules have two types that can be targeted at either nodes or edges: . | “Presence” Rules: These rules allow you to query if a given entity of a specified type exists in the network, using either the exists or not exists operator. This rule type is not generally useful for most typical filtering operations, but can be used when roster data contains nodes or edges of multiple types. | “Attribute” Rules: These rules allow you to query the value of a variable on a given entity type. For example, you may query the value of a variable called age on an alter type called ‘Person’. You can evaluate the result using one of several logical operators, that vary depending on the variable type. For example, number variables will let you query using operators such as ‘greater than’ and ‘less than’. | . Unlike skip logic rules (which are aggregated into an overall boolean true or false value), filter rules are applied to each node and edge in the network, and are not aggregated. Instead, the nodes that remain are those that satisfy the rule constraints. It is important to remember that filtering retains the validity of the network model: the returned network will not contain orphaned nodes when using an edge query, or partially disconnected edges, since these are not phenomenologically valid. The Join Operator . Rules are chained together (or ‘joined’) using either AND or OR logic, which is set in the network filter configuration section using the “Must match” options “all rules” and “any rules” respectively. These methods behave much as you might expect. In the context of a filter operation: . | OR signifies that if a node or edge meets any individual rule criteria, it will be returned in the overall network. | AND signifies that nodes and edges in the returned network should satisfy the criteria from all rules. | . This means that the choice of join operator can have an extremely significant impact on the way that your rules are collectively evaluated. You should be careful to only use the AND operator to chain together multiple required property values when all values are simultaneously required on a single node. Extended Example . Since network filtering can be confusing to new users, here is an extended example to illustrate the feature that includes both node and edge rules. Consider an interview where you use the Sociogram to generate sex ties between alters and to collect boolean attribute data on HIV status of alters. Let’s imagine that you then want to use a Per Alter Form or another name interpreter to capture data on drug use behavior of alters, but only those who are HIV positive and who have a sex relationship with another alter in the network. To achieve this using network filtering, we implemented the following edge and node rules on the Per Alter Form: . Applying these rules within this stage determines that only HIV+ nodes who have a sex relationship will be shown. All nodes that do not have a sex relationship will be filtered out - even if they have attribute HIV_pos = true. If your filter query (the sum of all defined rules within the stage) includes an edge rule, you will also filter alters. For example, if your rule is set to filter the existence of an edge type, such as ‘sex’, any nodes that would become isolates as a result of this query are removed from the filtered network. ",
    "url": "/key-concepts/network-filtering/#configuring-network-filtering-on-a-stage",
    "relUrl": "/key-concepts/network-filtering/#configuring-network-filtering-on-a-stage"
  },"136": {
    "doc": "Network Filtering",
    "title": "Network Filtering in a Side Panel",
    "content": "You also have the ability to filter the content of Name Generator side panels (where they are used). This features works exactly the same way as stage level network filtering, except that the results are only applied to the specific side panel you are configuring. Any filtering you set will apply across all prompts for that stage. This feature can be particularly useful if you wish to filter elements of a roster. For example, your roster may contain an attribute that represents graduation year that you could use to filter the side panel content for a question about classmates known from a certain year group. ",
    "url": "/key-concepts/network-filtering/#network-filtering-in-a-side-panel",
    "relUrl": "/key-concepts/network-filtering/#network-filtering-in-a-side-panel"
  },"137": {
    "doc": "Network Filtering",
    "title": "Network Filtering",
    "content": "Network filtering is a configuration feature you will find in several areas of Architect. Simply put, it allows you to define one or more rules that determine which nodes or edges should be shown on a given stage (or in a side panel - see below). It can be used to only show a subset of the network. This is particularly useful in cases where the content of the stage does not apply to all network entities. Consider the example of an interview protocol with two stages - a Name Generator, and an Ordinal Bin. On the first stage, for each alter named the participant is asked if they play sports with the individual. The second stage asks “how often do you play sports with each of these people?”. Filtering the network for this second stage to show only those alters with the “plays sports with” attribute will reduce the response burden of the task, and will make the interview protocol more efficient. Network filtering is different from skip logic! Although the two sound similar in principle, they achieve very different design goals. Whereas network filtering determines which nodes to show within a stage, skip logic determines if a stage should be shown at all. Consult the article on skip logic to learn more. ",
    "url": "/key-concepts/network-filtering/",
    "relUrl": "/key-concepts/network-filtering/"
  },"138": {
    "doc": "Pairing",
    "title": "Pairing",
    "content": "Pairing is the process which enables secure communication between an Interviewer client and Server. If you have paired devices before using Bluetooth, you can think about pairing in Network Canvas as a similar process - one device initiates pairing by exchanging a password with another device in order to establish a trusted connection through which information can be shared. For further information on the technical implementation, see our security model documentation. Pairing is necessary for Interviewer clients to both retrieve information from Server (e.g. the protocol file) and transmit information back to Server automatically (e.g. send interview data without exporting the file from Interviewer and importing it into Server). ",
    "url": "/key-concepts/pairing/",
    "relUrl": "/key-concepts/pairing/"
  },"139": {
    "doc": "Preview Mode",
    "title": "Using Preview Mode",
    "content": "To use preview mode, click the card of the stage you wish to preview. Once on the stage configuration screen, click the large pink button in the bottom left corner. A window will open which displays the stage as it would appear in the Interviewer app. From there, you can cycle through the stage prompts and complete any stage specific activities. If you wish to preview more than one stage, continue advancing to subsequent stage(s) until you reach the end of your protocol. You can exit preview mode at any time by closing the window. Data you enter will carry forward to subsequent stages so long as you keep the preview mode window open. As soon as the window is closed, any data entered will be lost as preview mode does not permanently store data. ",
    "url": "/key-concepts/preview-mode/#using-preview-mode",
    "relUrl": "/key-concepts/preview-mode/#using-preview-mode"
  },"140": {
    "doc": "Preview Mode",
    "title": "Caveats",
    "content": "Please note that in order to preview certain screens effectively, such as the sociogram, you will need to begin the preview in a name generator stage and enter some dummy data that can be used to preview subsequent screens. If you do not generate nodes first, the subsequent screens you preview will appear blank since there will be no data to display objects. ",
    "url": "/key-concepts/preview-mode/#caveats",
    "relUrl": "/key-concepts/preview-mode/#caveats"
  },"141": {
    "doc": "Preview Mode",
    "title": "Preview Mode",
    "content": "Preview mode is a feature within Architect that allows users to interactively preview their protocols on a per stage basis in real-time. In this mode, users can preview their protocol, by stage or in its entirety, just the way it would display on an Interviewer client in the field. This function is particularly helpful in protocol design and editing phases of a study, where a user may want to preview changes they implement immediately prior to deploying their protocol to the Interviewer app. ",
    "url": "/key-concepts/preview-mode/",
    "relUrl": "/key-concepts/preview-mode/"
  },"142": {
    "doc": "Prompts",
    "title": "Creating prompts",
    "content": "When creating prompts, text instructions must be specified. Prompts can contain formatting such as bold or italicized text to create emphasis and rhythm. To create this formatting, use markdown syntax. Editing a prompt in Architect Prompts can also be created to automatically assign “true” or “false” values to additional variables to track where in an interview an entity was included, or to add to an entity. ",
    "url": "/key-concepts/prompts/#creating-prompts",
    "relUrl": "/key-concepts/prompts/#creating-prompts"
  },"143": {
    "doc": "Prompts",
    "title": "Prompts in Interviewer",
    "content": "Most stages use “pips” to indicate progress through the prompts, and the progress bar moves forward incrementally as the interview steps through each prompt. Pips above the question on a prompt in Interviewer indicate progress on the stage ",
    "url": "/key-concepts/prompts/#prompts-in-interviewer",
    "relUrl": "/key-concepts/prompts/#prompts-in-interviewer"
  },"144": {
    "doc": "Prompts",
    "title": "Prompts",
    "content": "Most stages use the concept of “prompts” that define questions to put to the participant during the interview. This can be explained to the participant in ways that are meaningful to your study. A single stage may contain multiple prompts, or a single prompt, depending on the needs of the interview. You may wish to think about grouping prompts by theme, and then having one stage for each theme. For example, a “Name Generator (family)” stage could contain prompts about family alters, and “Name Generator (colleagues)” could contain prompts about professional alters. Multiple prompts on a name generator stage in Architect. ",
    "url": "/key-concepts/prompts/",
    "relUrl": "/key-concepts/prompts/"
  },"145": {
    "doc": "Resources",
    "title": "Adding Resources to a Stage",
    "content": "Many stages allow you to add resources directly while configuring them. This is designed to provide a more seamless flow when creating your interview protocol. Examples of this include background images on the Sociogram interface, roster files in either of the roster Name Generators, and media files on the Information interface. If the stage you are supporting uses a resource it will provide an interface for you to add it directly, and will give instructions about which type of resource is required. ",
    "url": "/key-concepts/resources/#adding-resources-to-a-stage",
    "relUrl": "/key-concepts/resources/#adding-resources-to-a-stage"
  },"146": {
    "doc": "Resources",
    "title": "Adding and Removing Resources from the Resource Library",
    "content": "For a more broad overview of all resources within your current protocol, click the ‘resource library’ button in the upper right hand corner of the protocol overview card, when looking at the timeline. This will open the Resource Library. Under the resource library screen, you can browse, filter, and delete any existing resources, as well as add new ones. To add a new resource to the resource library, simply drag and drop a file into the designated area, or browse for the file you wish to import. You will notice that existing resources that are unused show a red “unused” pill. This indicates that they are able to be deleted. Attempting to delete an resource that is in use within your interview will be prevented. You must first update or remove all uses of a resource before you can delete it. ",
    "url": "/key-concepts/resources/#adding-and-removing-resources-from-the-resource-library",
    "relUrl": "/key-concepts/resources/#adding-and-removing-resources-from-the-resource-library"
  },"147": {
    "doc": "Resources",
    "title": "Supported File Types",
    "content": "Image . Interviewer supports JPEG, GIF, and PNG image file formats. Audio . Interviewer supports MP3, AIFF, M4A, and MP4 audio file formats. Video . Interviewer supports MP4 and MOV video file formats. Take special care when using video to make your files as small as possible. Network . Interviewer supports network data in CSV format. The heading row will be used to set variable names for any nodes brought in to the interview. Ensure that you have a column called “name” to take advantage of automatic node labelling. Download a simple example CSV file from here. ",
    "url": "/key-concepts/resources/#supported-file-types",
    "relUrl": "/key-concepts/resources/#supported-file-types"
  },"148": {
    "doc": "Resources",
    "title": "Resources",
    "content": "In Architect, ‘resources’ are any external files that you use within your interview. These can be media files, such as audio, images, or even video. They can also be network data files that you can use as a roster. Careful use of resources can improve the interview experience for your participants, or enable different types of interview workflow. Once added to your protocol in Architect, resources are stored within the .netcanvas file itself. Because of this, you will need to handle updating or removing resources from within Architect. Using large numbers of resources, or resources that are poorly optimized, in your protocol can heavily impact performance. This means that protocols take longer to install on devices, and some stages may take much longer to load. Special care must be taken to appropriately resize and compress your resources before importing them, and you must ensure that you have tested your protocol on your intended field devices to ascertain performance levels.As a general guide, you should aim to have your total protocol file size be less than 10mb. ",
    "url": "/key-concepts/resources/",
    "relUrl": "/key-concepts/resources/"
  },"149": {
    "doc": "Skip Logic",
    "title": "Adding Skip Logic to a Stage",
    "content": "To add skip logic to a stage, open it from the timeline view, and click “Use skip logic” to expand the section. To disable skip logic for a stage, click the toggle at the top of this section. You can see which stages have skip logic enabled by looking for the skip logic icon next to the stage on the timeline. ",
    "url": "/key-concepts/skip-logic/#adding-skip-logic-to-a-stage",
    "relUrl": "/key-concepts/skip-logic/#adding-skip-logic-to-a-stage"
  },"150": {
    "doc": "Skip Logic",
    "title": "Skip Logic Rules",
    "content": "Constructing rules is the most fundamental part of creating skip logic. There are various types of rules, depending on the network entity that is being targeted: . | “Presence” Rules: These rules allow you to query if a given entity of a specified type exists in the network, using either the exists or not exists operator. This rule type is available for alter and edge rules. | “Attribute” Rules: These rules allow you to query the value of a variable on a given entity type. For example, you may query the value of a variable called age on an alter type called ‘Person’. You can evaluate the result using one of several logical operators, that vary depending on the variable type. For example, number variables will let you query using operators such as ‘greater than’ and ‘less than’. This rule type applies to alter and ego rules only. | . ",
    "url": "/key-concepts/skip-logic/#skip-logic-rules",
    "relUrl": "/key-concepts/skip-logic/#skip-logic-rules"
  },"151": {
    "doc": "Skip Logic",
    "title": "The Join Operator",
    "content": "Rules are chained together (or ‘joined’) using either AND or OR logic, which is set in the skip logic configuration section using the “Must match” options “all rules” and “any rules” respectively. The joining operators govern how multiple rules are evaluated together to determine the overall boolean value that the query returns. If rules are joined by AND statements, and all individual rules evaluate to true, so will the top level constraint (for example: true &amp;&amp; true === true). Conversely, if any individual rules evaluate to false, so too will the top level constraint (true &amp;&amp; false === false). If rules are joined by OR statements, any individual rule evaluating truthfully will cause the top level constraint to also evaluate as true (true || false || false === true). This means that the choice of join operator can have an extremely significant impact on the way that your rules are collectively evaluated. One way of thinking about the difference is that you should use the “all rules” option in situations where there is only one scenario where a stage should be shown. You can then add as many rules as you need to ensure that this scenario is as specific as possible. Alternatively, use the “any rules” option for situations where there are many reasons a stage should be shown. For example you may show an information screen with an embedded intervention video if a participant has demonstrated any one of a number of risk behaviors. ",
    "url": "/key-concepts/skip-logic/#the-join-operator",
    "relUrl": "/key-concepts/skip-logic/#the-join-operator"
  },"152": {
    "doc": "Skip Logic",
    "title": "Skip or Show",
    "content": "Before we know the final outcome of the skip logic rule, we have to consider one last configurable property: the “show this stage if” or “skip this stage if” selector. This option simply allows you to decide if a ‘true’ outcome from evaluating your rules should cause the stage to be skipped or to be shown. This effectively allows you to write rules in terms of negatives - that is, to instead write rules that define when a stage should be shown rather than when it should be skipped. This can be more useful if you have a lot of values to include or exclude. For example, if you wished to skip a stage based on if a categorical variable with many options is set to all but one possible value, you would typically have to write a rule for each value, and use the OR operator. However, if you were to set the skip logic to “show this stage if”, you would only need to define a single rule, that included the value that is specifically permissible. Take extra care to think through the logical repercussions of your join operator when changing this property, as it can be somewhat counter-intuitive. It is very easy to make your rule too specific using the AND operator! . ",
    "url": "/key-concepts/skip-logic/#skip-or-show",
    "relUrl": "/key-concepts/skip-logic/#skip-or-show"
  },"153": {
    "doc": "Skip Logic",
    "title": "Extended Example",
    "content": "Since skip logic can be confusing to new users, we have provided an extended example below. Consider an interview where you are using a Categorical Bin Interface to classify the participant’s relationship with alters. You define options including ‘friend’, ‘spouse/partner’, ‘coworker’, ‘parent’, ‘sibling’, ‘child’, ‘uncle/aunt’, or ‘grandparent’ with corresponding values of 1, 2, 3, 4, 5, 6, 7, and 8. In the following stage you want to use another Categorical Bin, but this time to capture type of relatedness of alters to ego (e.g. ‘biological’, ‘step’, ‘adoptive’, ‘through marriage’, etc.). Now let us imagine that a participant did not nominate any alters to whom they are related (i.e. they have only nominated friends, spouse/partners, and/or coworkers). In such an instance, the type of relatedness stage would be irrelevant and, therefore, implementing skip logic to skip this stage entirely for such a participant would both increase efficiency and minimize respondent burden. We implemented a simple skip logic rule to address this, as follows: . In the above example, you could also configure your skip logic to achieve the same outcome by implementing the inverse rule (i.e. skip screen if alter of a type Person with Relationship excludes 4, 5, 6, 7, or 8). In either case, once you create more than one rule in your skip logic for a given stage, you need to determine whether you want all the rules matched or just any of the rules matched. In keeping with the examples above, let’s imagine that you want to create a subsequent screen to capture data about a participant’s biological nuclear family. You want this screen to be shown if a participant previously nominated alters with Relationship type ‘parent’, ‘sibling’ or ‘child’ and where these alters include type Relatedness of ‘biological’. Here you would use the ALL operator since you would not want the stage to be shown if the participant has alters in their network of Relationship type ‘parent’, ‘sibling’ or ‘child’ but none of them include type Relatedness ‘biological’. ",
    "url": "/key-concepts/skip-logic/#extended-example",
    "relUrl": "/key-concepts/skip-logic/#extended-example"
  },"154": {
    "doc": "Skip Logic",
    "title": "Skip Logic",
    "content": "Skip logic is a feature within Interviewer that allows you to conditionally skip or show stages within the interview, based on the current information in the interview network. By skipping or showing certain stages, you are able to direct the path a participant takes through your protocol. For example, if a participant indicates on an ego form stage that they have never used drugs, you may configure your protocol using skip logic to not show them subsequent name interpreter stages that ask about drug use with alters. The following is a high level overview of the way that this feature works: . | Skip logic is configured by creating one or more rules, based on the attributes of ego, alters, or edges. | These rules resolve to either true or false when the the stage is about to be shown. | The value of the individual rules is then aggregated into a global true or false value, using either AND or OR logic. | The aggregated result is then evaluated in terms of if the intent is to describe when to show the stage, or when to skip the stage. | Based on this, the stage will either be shown or skipped. | . ",
    "url": "/key-concepts/skip-logic/",
    "relUrl": "/key-concepts/skip-logic/"
  },"155": {
    "doc": "The Protocol File",
    "title": "Authoring Protocol Files",
    "content": "Architect will create your protocol file automatically when you create a new protocol. As you add stages, edit content, or upload resources to your protocol, Architect will prompt you to save your changes. These changes will be stored within the protocol file. Once you deploy your protocol to other applications, however, be aware that making changes effectively makes your protocol a new version. If you find that you need to make changes after deploying it, you have two options. It is recommended to save a copy of your protocol with a new name after making changes, and to import the new version to Interviewer and Server. The other option is to remove the existing protocol (and any interview data) from Server and Interviewer and upload the newer version. This is necessary to ensure compatibility across tools. If you choose to create or edit a protocol file by hand, you will be responsible for ensuring it follows all specifications for the current schema. ",
    "url": "/key-concepts/the-protocol-file/#authoring-protocol-files",
    "relUrl": "/key-concepts/the-protocol-file/#authoring-protocol-files"
  },"156": {
    "doc": "The Protocol File",
    "title": "Using Protocol Files",
    "content": "Once your protocol file is complete, you can then use this file in Server and Interviewer. See importing a protocol into Interviewer or creating and managing workspaces in Server for more. ",
    "url": "/key-concepts/the-protocol-file/#using-protocol-files",
    "relUrl": "/key-concepts/the-protocol-file/#using-protocol-files"
  },"157": {
    "doc": "The Protocol File",
    "title": "The Protocol File",
    "content": "Network Canvas protocols are stored in a file with the extension .netcanvas. They are just like any other files on your computer, meaning you can move them around, rename them, and you can (and should!) back them up. The .netcanvas file contains all of the data in your protocol. So if you use any resources, such as roster data, images, or video, these will be embedded within the file. ",
    "url": "/key-concepts/the-protocol-file/",
    "relUrl": "/key-concepts/the-protocol-file/"
  },"158": {
    "doc": "Developer Contribution Guide",
    "title": "Developer Contribution Guide",
    "content": " ",
    "url": "/reference/developer-contribution-guide/",
    "relUrl": "/reference/developer-contribution-guide/"
  },"159": {
    "doc": "IRB and Security Best Practices",
    "title": "Secure Data Transfer",
    "content": "Our remote transfer functionality (i.e. the workflow with Server) uses end-to-end encryption to ensure that your data cannot be intercepted by a third party as it is sent remotely back to your laboratory or department computer. This transfer can take place on a local network within your institution, for added security. Data transmitted between Network Canvas and Server are encrypted using a symmetric encryption algorithm called Advanced Encryption Standard (AES) which secures its integrity before transmission. Once the data are encrypted, they are sent securely to Server using Transport Layer Security (TLS). ",
    "url": "/reference/irb-best-practices/#secure-data-transfer",
    "relUrl": "/reference/irb-best-practices/#secure-data-transfer"
  },"160": {
    "doc": "IRB and Security Best Practices",
    "title": "Data Storage",
    "content": "Where Network Canvas data is stored is up to the researcher. Server is a desktop application that facilitates secure transfer and management of study data, but it does not provide a storage solution. We do not transmit, collect or retain any data from or about any study. The data collected in the field is yours, and is only ever stored on your devices. Additionally, we do not use cookies or other tracking tokens of any kind within Network Canvas. ",
    "url": "/reference/irb-best-practices/#data-storage",
    "relUrl": "/reference/irb-best-practices/#data-storage"
  },"161": {
    "doc": "IRB and Security Best Practices",
    "title": "Security Best Practices",
    "content": "Since the onus of data storage and device security is on the researcher, we suggest the following best practices to ensure the security of your Network Canvas study data: . | Turn on full-disk encryption (OS). Network Canvas and Server do not encrypt their data stores, since the keys would be trivial to uncover from within the apps themselves. | Use strong passwords/passcodes on devices. Implement user access controls to prevent multi-user systems from granting access to data from other user accounts. | Restrict physical access to devices. The use of ‘kiosk’ modes (or similar), along with full constant supervision of the interview, to prevent research participants from accessing data within the app. | Minimize time study data remains on field devices. Uploading data to designated secured storage locations as regularly as possible, and then deleting it from field devices, helps limit risk of breach (e.g. a device being stolen). | Only access Server on a local network or through a VPN. Using VPN technology, secured ad-hoc networks, an “air gap”, or other common security techniques when transferring data between field devices and Server. These technologies can often supplement the security measures already within the software. Never expose Server to the public internet. | Periodically re-pair your devices. Re-pairing allows your devices to refresh their encryption code which helps to minimize the potential for any interception. | . ",
    "url": "/reference/irb-best-practices/#security-best-practices",
    "relUrl": "/reference/irb-best-practices/#security-best-practices"
  },"162": {
    "doc": "IRB and Security Best Practices",
    "title": "IRB and Security Best Practices",
    "content": "We recognize that data security is a primary concern for most researchers. Network Canvas was born in the context of sensitive public health research with marginalized populations, and we have used our experience conducting studies in this space to guide our security paradigm. Network Canvas uses modern security features, and has built on existing technologies and widely used implementations. Our data security approach focuses on data transfer, since we work on the assumption that devices running the Suite will be fully controlled by researchers, and in the case of dedicated data storage devices running Server, will operate in secure networking contexts. This means that data transfer is the most vulnerable step in the workflow. ",
    "url": "/reference/irb-best-practices/",
    "relUrl": "/reference/irb-best-practices/"
  },"163": {
    "doc": "Node Labelling",
    "title": "How Interviewer Calculates a Node’s Label",
    "content": "Interviewer calculates the label to be used when rendering a node using the the following logic: . | Use any node label worker that is within the protocol (see section below for details on this advanced feature). | Look for a variable called “name” (regardless of case) in the codebook for node’s type, and try to retrieve this value from the node. | Look for a property on the node with a key of ‘name’ (regardless of case), and try to retrieve this value. | Show the text “No ‘name’ variable!” | . If you are seeing unexpected results, such as “No ‘name’ variable!” messages, ensure you have constructed your protocol or your data in a way that satisfies a rule with a higher precedence. For example, ensure you have correctly created a ‘name’ variable for the node type, and that this variable is assigned a value within your interview. For advanced functionality, such as calculating a node label dynamically, see “custom node labelling”. ",
    "url": "/reference/node-labelling/#how-interviewer-calculates-a-nodes-label",
    "relUrl": "/reference/node-labelling/#how-interviewer-calculates-a-nodes-label"
  },"164": {
    "doc": "Node Labelling",
    "title": "Labelling Nodes from Roster Data",
    "content": "To control the labelling of nodes from network file assets, the following options are available: create an attribute for your nodes called “name” (regardless of case). You can implement this attribute as a column in your CSV file, or as a named attribute in a GraphML file. See also: working with assets. ",
    "url": "/reference/node-labelling/#labelling-nodes-from-roster-data",
    "relUrl": "/reference/node-labelling/#labelling-nodes-from-roster-data"
  },"165": {
    "doc": "Node Labelling",
    "title": "Custom Node Labelling (Advanced)",
    "content": "For more flexible labelling of nodes, you can implement a custom labelling function. To accomplish this, you would: . | Add nodeLabelWorker.js to your protocol (see: the protocol file format for details of how to do this) | Within this file, define a function named nodeLabelWorker | Return a string from that function, which will be used as the label. | . nodeLabelWorker is called with an object containing information about the node and network, and should return the label (a string) for the given node. Conceptually: f(node, network) -&gt; label. Thus you can update labels for nodes based on the changing state of the network, or an individual node’s attributes. Here’s a simple example which will label every node with a compound property (initial + surname): . /** * @param {Object} data * @param {Object} data.node All props for the node requiring a label * @param {string} data.node.networkCanvasId Unique ID for the node. Note that if your data * happens to already contain a property named * \"networkCanvasId\", your prop will take precedence, * and this cannot be used to identify edge connections. * @param {Object} data.network The current state of the network in this session * @param {Array} data.network.nodes Each node has a unique `networkCanvasId` prop * @param {Array} data.network.edges Edges contain `to` and `from` props which * correspond to nodes' `networkCanvasId` values * * @return {string|Promise} a label for the input node, or * a promise that resolves to the label */ function nodeLabelWorker({ node, network }) { return `${node.first_name[0]} ${node.last_name}`; } . In addition to attributes specified from a protocol, each node will contain a unique networkCanvasId property which can be used to identify the node in the network. The nodeLabelWorker function will be executed asynchronously in a Web Worker environment. It will be further restricted by the Content Security Policy of the app; you should not rely on network access within the labelling function. For a more complete example, see the nodeLabelWorker in the development protocol. ",
    "url": "/reference/node-labelling/#custom-node-labelling-advanced",
    "relUrl": "/reference/node-labelling/#custom-node-labelling-advanced"
  },"166": {
    "doc": "Node Labelling",
    "title": "Node Labelling",
    "content": " ",
    "url": "/reference/node-labelling/",
    "relUrl": "/reference/node-labelling/"
  },"167": {
    "doc": "Protocol File Format",
    "title": "Protocol File Format",
    "content": " ",
    "url": "/reference/protocol-file-format/",
    "relUrl": "/reference/protocol-file-format/"
  },"168": {
    "doc": "Protocol Schema Information",
    "title": "Summary",
    "content": "Interviewer and Architect (from version 4.2.0 onward) implement a feature that tracks the version of the protocol file format, or “schema”, associated with any protocol files that you author or work with. You may notice messaging within the app that informs you of “out of date”, or “obsolete” schema versions associated with your protocol. This article will explain these concepts in greater detail. The key takeaway is that as long as your schema is not marked “obsolete”, you can continue to use Interviewer to collect and export data, exactly as before. Although every effort is made to maintain compatibility with new schema versions, any features implemented that require a schema update will be unavailable to you until you migrate your protocol. We strongly encourage you to update your protocol files wherever possible, so that you are able to use the newest Network Canvas features. We urge iPadOS and Android users to follow the advice set out in the configuring devices prior to starting data collection article, and disable automatic app updates so that they are not caught out by breaking changes that result from new protocol schema versions. This is essential if users wish to continue using a particular version of an app to ensure it remains compatible with their existing protocols (rollback to prior versions is not possible on these platforms). ",
    "url": "/reference/protocol-schema-information/#summary",
    "relUrl": "/reference/protocol-schema-information/#summary"
  },"169": {
    "doc": "Protocol Schema Information",
    "title": "What is a protocol schema?",
    "content": "A protocol “schema” is a description of which configuration options a protocol can or cannot have in order to be considered ‘valid. It takes the form of a series of constraints and logical rules that define property names, data types, and structure. When a protocol is used within Architect or Interviewer, it is validated against a schema. Unexpected values, properties, or structures will trigger various types of warning or error message. We adopted schemas in an effort to ensure stability and consistency within the functioning of the software. If a protocol is valid according to its schema, it should function without issues. We need to “version” Network Canvas protocol schemas so that we can add or change features as we develop them. This could mean implementing a new interface, or changing the way that an existing function, such as skip logic, works. Simply changing an existing schema would make previously authored protocols invalid, or would lead to the software crashing. Our priority when implementing schema versioning has been to not burden the end user, either through creating “maintenance work” (for example by requiring older protocols to be updated manually), or by disrupting your workflow (for example by preventing existing protocols from functioning). ",
    "url": "/reference/protocol-schema-information/#what-is-a-protocol-schema",
    "relUrl": "/reference/protocol-schema-information/#what-is-a-protocol-schema"
  },"170": {
    "doc": "Protocol Schema Information",
    "title": "What it means for you",
    "content": "When you update Interviewer or Architect, you may encounter messages when using protocols that were authored in prior versions of the apps. In Interviewer, you may see a blue light bulb icon, or a red robot icon, on your protocol card. Where a new schema is backward-compatible with a prior version you will see a blue light bulb, and Interviewer will continue to support installing and running protocols of that version without any issues. This means that if you are happy with your protocol file you do not need to take any action. Your protocol will continue to function as before, albeit without access to new functionality implemented with the new schema version (see the schema versions table below for details on this). If you wish to update the protocol file to the new schema version, follow the instructions provided below under migrating a protocol. If your protocol is no longer compatible with the version of Interviewer that you have installed, you will see a red robot icon, and will no longer be able to start an interview. Please see the section below on handling obsolete protocols for further assistance. In Architect, you may see a prompt that a protocol must be migrated to a newer version before it can be opened (see below). If you wish to update their protocol file to the new schema version, follow the instructions provided below under migrating a protocol. If you would like to continue editing this protocol without migrating it to the latest version, you will need to downgrade your version of Architect. See the GitHub releases page for an archive of old versions, and consult for the compatibility table for information about which version you need. ",
    "url": "/reference/protocol-schema-information/#what-it-means-for-you",
    "relUrl": "/reference/protocol-schema-information/#what-it-means-for-you"
  },"171": {
    "doc": "Protocol Schema Information",
    "title": "Handling obsolete protocols",
    "content": "Although we aim to always make schema changes that are backward-compatible, this can be unavoidable if we need to substantially revise a feature. If a new schema version is implemented that is not backward-compatible, the user interface in Interviewer will mark the protocol as “obsolete” and will no longer allow new interview sessions to be started. Although this is obviously undesirable, all existing session data will continue to be exportable from a protocol in this state. Review the section below to understand your options in this scenario. Although obsolete protocols will still be able to be migrated to the latest schema version by Architect, in some cases manual intervention or updating may be required. For example, if we add required properties to the protocol that cannot be derived from existing properties, you may need to create these yourself. Please contact us if you have encountered an issue, or have specific concerns about this. What to do if your protocol is marked as obsolete . If your protocol is marked as obsolete, and you wish to continue collecting data using it, you have two options: . | Migrate the protocol to a later version, which is compatible with your version of Interviewer. See migrating a protocol below for this. | Downgrade an older version of Interviewer, by uninstalling your current version, and downloading the version you require from our GitHub releases page. As per the warning at the start of this article, downgrading is not possible on iOS or Android platforms. If you have mistakenly upgraded your Interviewer version on these platforms causing your protocol to become obsolete, your only choice is to migrate your protocol to the latest schema version and to redeploy it. | . ",
    "url": "/reference/protocol-schema-information/#handling-obsolete-protocols",
    "relUrl": "/reference/protocol-schema-information/#handling-obsolete-protocols"
  },"172": {
    "doc": "Protocol Schema Information",
    "title": "Migrating a protocol",
    "content": "Migrating a protocol happens within Architect, and is automatic. The process works as follows: . | Ensure you are on the latest version of the Architect app. When opening the app with an active internet connection, the app will check for updates automatically, and notify you if any are found. Alternatively, you can manually update the app, by visiting our download page and installing the latest version for your platform. | Once you are running the latest version, open the protocol file that you wish to migrate. | Architect will inform you that the protocol file can be upgraded, which happens by creating a copy (so that your original file is preserved). If you choose to continue, you will be prompted for a location to save your upgraded protocol. | Architect will automatically append “(schema version X)” to the filename, which may help you to keep track of the different versions of your protocol, and to differentiate them within Server and Interviewer. | . Schema changes may represent changes to the underlying network data model and, therefore, protocols migrated from one schema version to another must be treated as different workspaces within Server (shown below). Users that do migrate their protocols to a new schema compatible version will need to create a merging script to handle combining the two data sources from the two workspaces once exported. Although this process introduces an extra step in a user workflow, it promotes better quality data and greater user control. ",
    "url": "/reference/protocol-schema-information/#migrating-a-protocol",
    "relUrl": "/reference/protocol-schema-information/#migrating-a-protocol"
  },"173": {
    "doc": "Protocol Schema Information",
    "title": "Compatibility Table",
    "content": "Consult the table below for information about which schema versions are supported by each released version of the Network Canvas software. | Interviewer Version | Main Schema Version | Interviewer Supported Schema Versions | . | 6.1.0 | 5 | 4,5 | . | 6.0.1 | 4 | 4 | . | 6.0.0 | 4 | 4 | . ",
    "url": "/reference/protocol-schema-information/#compatibility-table",
    "relUrl": "/reference/protocol-schema-information/#compatibility-table"
  },"174": {
    "doc": "Protocol Schema Information",
    "title": "Schema Versions",
    "content": "Version 5 (planned) . | Implements the “tie-strength census” interface | Includes new validation options for form fields | Adds a separate variable type for multiple-option categorical variables | . Version 4 . | Initial stable release version of the protocol schema | . ",
    "url": "/reference/protocol-schema-information/#schema-versions",
    "relUrl": "/reference/protocol-schema-information/#schema-versions"
  },"175": {
    "doc": "Protocol Schema Information",
    "title": "Technical implementation of schema migration",
    "content": "The following section may be useful if you are attempting to understand how schema migration is performed on a technical level. In rare cases, this may help you to troubleshoot an issue with a migrated protocol yourself, should you wish. | A migration between two sequential schema versions is a functional transformation of the protocol object. These transformations are written as simple functions that take a protocol object, mutate it, and return the mutated protocol. Migration functions are defined in the protocol-validation submodule. | Transformations can be chained together, meaning that a protocol can be migrated from version 1 to version n by applying all transformations in between in sequence [1 … n]. | We plan a parallel system of “patching”, which will use the same technique as migration, but is designed to address any data corruption issues caused as a result of bugs in Architect. Patches are designed to fix protocol issues without updating the schema version. | . ",
    "url": "/reference/protocol-schema-information/#technical-implementation-of-schema-migration",
    "relUrl": "/reference/protocol-schema-information/#technical-implementation-of-schema-migration"
  },"176": {
    "doc": "Protocol Schema Information",
    "title": "Protocol Schema Information",
    "content": " ",
    "url": "/reference/protocol-schema-information/",
    "relUrl": "/reference/protocol-schema-information/"
  },"177": {
    "doc": "Overview of Security Model",
    "title": "What data needs to be secured",
    "content": "Protocols . Protocols not only include the general structure of an interview but any datasets that are necessary to conduct an interview. For example a study in a school may include a roster of the names of other classmates. Session data . Session data is the term used to describe participant response data. This may include sensitive personal information, especially in the domain of healthcare. The applications also store metadata, including the date that the session was conducted which may reveal participant whereabouts. App configuration and metadata . Each app stores a metadata about protocols as well as application-specific settings. In Server: . | Paired device metadata, including the device name and the device secret key | Protocol metadata, such as when they were installed. | . In Interviewer: . | Information about application display settings | Server data, including public certificate and IP address | . In Architect: . | Protocol metadata, such as which protocol was edited last. | . ",
    "url": "/reference/security-model/#what-data-needs-to-be-secured",
    "relUrl": "/reference/security-model/#what-data-needs-to-be-secured"
  },"178": {
    "doc": "Overview of Security Model",
    "title": "How data is secured",
    "content": "Data at rest . The main application data stores are unencrypted at rest, this applies to: . | Protocols | Session data | Application configuration. | . Because data stores are not encrypted it is important that operating system level security features are in use. Disk encryption . Disk encryption should be enabled to ensure that data cannot be accessed if the device is lost or stolen. In Windows this feature is called “Device encryption” For macOS this feature is called “FileVault”. In android this feature is called “Full-Disk Encryption”. iOS encrypts the device by default. For Linux, it will depend on the distribution; Ubuntu comes with out-the-box disk encryption using LUKS with LVM. Secure passwords . Your device(s) should be configured with strong passwords and to lock automatically from inactivity - or better yet should be manually locked when not in use. This is to prevent access to data when you or the user are not present. Data in transit . Data transferred between Server and Interviewer is encrypted using TLS. | Protocols: when using the “Import from Server” feature in Interviewer | Session data: when using the “Export to Server” feature in Interviewer | . Additionally, metadata is transferred between Server and Interview when pairing devices. This is done using Secretbox from libsodium, using the pairing code as an “out of band” key exchange. VPN . It is strongly advised that a VPN is used when using Server in tandem with Interviewer. You may be using one already if you use a device managed by an IT department. Using a VPN will provide more comprehensive security for the transmission of data, as although every effort has been made to ensure security between the apps, this is much more likely to include bugs that the tried and battle tested VPN tools that already exist. ",
    "url": "/reference/security-model/#how-data-is-secured",
    "relUrl": "/reference/security-model/#how-data-is-secured"
  },"179": {
    "doc": "Overview of Security Model",
    "title": "Overview of Security Model",
    "content": "Security is an important consideration when handling study data. | Sessions may contain personal participant information which needs to be kept private | Protocols may include information about participants which needs to be kept private | Studies need to be able to ensure that collected data is genuine to ensure the integrity of the research. | . ",
    "url": "/reference/security-model/",
    "relUrl": "/reference/security-model/"
  },"180": {
    "doc": "Project Testing Strategy",
    "title": "Current Approach",
    "content": "Currently projects use a mixture of enzyme snapshot tests and unit/integration tests. There is an integration (or end to end) test suite. which ensures the apps (electron only) are compatible with one another: https://github.com/codaco/integration-tests. A protocol validation schema allows testing of protocol files in the live apps, but itself is relevant to testing in that it can be used to ensure the apps can produce/consume valid interviews. Appium was trialed for similar integration testing for mobile, but the approach proved slow, brittle and prone to false positives. ",
    "url": "/reference/testing-strategy/#current-approach",
    "relUrl": "/reference/testing-strategy/#current-approach"
  },"181": {
    "doc": "Project Testing Strategy",
    "title": "Review",
    "content": "Large software outfits such Google promote a unit testing focused approach, with only a minor role played by E2E (end to end) testing. Reasons given include: . | Overarching issues, such as a ‘login’, can cause the entire suite to fail, when this isn’t fixed immediately, many smaller bugs can be hidden, | E2E testing is slow, in the case of larger software suits, developers may have to wait until the next day to see results. | . Levels of testing . End to end Test the finished product (e.g., simulating running the application as a user) . Integration: Test composite components and/or the interaction of components, a middle ground between the two. Unit: Test individual functions and classes . Unit testing is favored because: . | It can provide immediate feedback | It is specific (can aid finding bugs) | . Rationale . In the case of the Network Canvas project, there are two overarching needs for testing: . | Acceptance testing: do the apps work as intended? | Documentation and ease of development: on boarding new contributors, bug fixing and documenting the intent of code. | . Because of these needs (acceptance testing) it may be that end to end testing should play a more central role in testing, despite the drawbacks. Current end to end tests are scarce, and non-spotted regressions can easily make it into releases. Whilst this is mitigated somewhat with manual tests, it would be preferable to automate longer term. There are enzyme snapshot tests for the UI, but aren’t providing any value. When they fail, it isn’t indicative of an actual issue and only a reflection of changes to the UI. They should be removed/discontinued, and replaced with E2E tests that simulate actual usage. The unit and integration tests are somewhat useful, especially when related to functional oriented code, such as format conversion. Some integration tests can be brittle when functionality is revised, but as the software matures, that will be less of an issue. ",
    "url": "/reference/testing-strategy/#review",
    "relUrl": "/reference/testing-strategy/#review"
  },"182": {
    "doc": "Project Testing Strategy",
    "title": "Summary of Strategy",
    "content": ". | Test what is important to the user . | E2E coverage should start 10,000ft and narrow down as needed | Test behavior, not implementation . | Architect: UI changes -&gt; creates a protocol which is valid | . | . | Tests should be as simple as possible to run . | Automated | Cohabit with code | Provide fast feedback loop | Runnable on CI (ideal) | . | Tests that aid future development . | Document intended functionality within tests to make intended input and output clear. | Shared mock state where considered canonical | Help to find bugs | . | . ",
    "url": "/reference/testing-strategy/#summary-of-strategy",
    "relUrl": "/reference/testing-strategy/#summary-of-strategy"
  },"183": {
    "doc": "Project Testing Strategy",
    "title": "Implementation of Strategy",
    "content": ". | Write end to end tests to document app usage. These will be used to validate that the application is fit for release. They should test UI interactions match expected outcomes, some examples: . | Network Canvas: When a user enters some text, the network should be modified as expected. | Architect: When a user clicks a button, the protocol should be modified as expected. | Server: When a user does X in the interface, then Y should happen to the network/protocol object. | Build a list of “core outcomes” (such as the above) that can be implemented immediately. Base this off of the manual checklist. | . | Write unit tests to document underlying infrastructure. These will be used to find bugs and ensure that utility functions work as expected. Core functionality such as saving and loading files is a good example requiring unit tests. | When saveProtocol() is called, the protocol should write to the disk (or call APIs that do). | When a network is converted to XML, the generated data is as expected. | . | Write unit and/or end to end tests to validate bug fixes. If you find yourself writing lots of log statements, this might be a good place to add a test. | . ",
    "url": "/reference/testing-strategy/#implementation-of-strategy",
    "relUrl": "/reference/testing-strategy/#implementation-of-strategy"
  },"184": {
    "doc": "Project Testing Strategy",
    "title": "General guidance",
    "content": ". | Test to an interface, for example on a React component you might check which prop functions (output) are called when a button is clicked (input). | Try to avoid testing implementation details. For example: . | If you are testing a composite component and need to specify component names. Instead use | If you need access to class variable names or functions to run the tests | . | . | When underlying code changes, making tests outdated ensure old tests are replaced to maintain code coverage. | Create (modular) factory generators for canonical mocks. Suggest using Rosie. Shared mock state should be used wherever possible, and established where it doesn’t currently exist. | The existing integration tests are still very relevant, but it would be good to be able to run them as part of each app. The integration-tests repo could them be adapted to run these suites together if desired. For example: Architect can be tested to produce a validated protocol, and network canvas can be tested to run a validated protocol as a separate step | . ",
    "url": "/reference/testing-strategy/#general-guidance",
    "relUrl": "/reference/testing-strategy/#general-guidance"
  },"185": {
    "doc": "Project Testing Strategy",
    "title": "Guidance for Reviewers",
    "content": "**TBC: **To enable the above strategy to be consistently implemented, we will develop a checklist for reviewers to help them when conducting a formal code review on a feature or bugfix PR. This will also help external collaborators, and could be included as part of a PR template. ",
    "url": "/reference/testing-strategy/#guidance-for-reviewers",
    "relUrl": "/reference/testing-strategy/#guidance-for-reviewers"
  },"186": {
    "doc": "Project Testing Strategy",
    "title": "How to test",
    "content": "Ideally tests should be written either before implementation or in parallel with implementation. Tests are written on top of Jest, which is part of the React project. Enzyme can be used to simulate small parts of UI, but this is not a reliable way to test UI, and should be treated as unit/integration type test. Spectron can be used to drive end to end tests. Bug fixes . | Write a functional or unit test to match the issue described. At this point the test should fail. | Implement the fix by making necessary until the test passes. | If you find yourself writing lots of logging statements to debug the problem, consider writing unit tests to cover those steps if it seems prudent to do so. | . New features . Whilst ideally this should cover the same steps as a bug fix, it may be that some experimentation is required until a fully testable implementation is made. In this case, it may still be possible to loosely write high level test stubs which can then be populated as the implementation materializes. | Write a high level functional/unit test stubs that describe the feature. | Implement the feature and the tests side by side, with precedence to the tests, where possible. | If you find yourself writing lots of logging statements to debug the problem, consider writing unit tests to cover those steps if it seems prudent to do so. | . Backfilling missing tests when developing new features/fixes . If you are implementing a bug fix or feature for a part of the app with no coverage, follow the principle of “leave it better than you found it”, e.g., if you add functionality to the sociogram interface, create a test harness for the whole interface, and stub (and/or implement) any tests that need to be implemented yet for that interface. ",
    "url": "/reference/testing-strategy/#how-to-test",
    "relUrl": "/reference/testing-strategy/#how-to-test"
  },"187": {
    "doc": "Project Testing Strategy",
    "title": "Metrics",
    "content": "Jest provides a code coverage feature which covers execution of branches, functions, lines and statements. Whilst useful for directing missing test coverage, it doesn’t exactly match what should be considered ‘good’ coverage. The aim should be for this report to get better over time, and if that isn’t the case review why figures are declining. For Spectron tests, aim for every part of UI to be tested (e.g., every clickable, draggable thing). Coverage is difficult to measure automatically so will need to be part of code review. ",
    "url": "/reference/testing-strategy/#metrics",
    "relUrl": "/reference/testing-strategy/#metrics"
  },"188": {
    "doc": "Project Testing Strategy",
    "title": "Feedback",
    "content": ". | screenshot / visual snapshot testing? Can jest do this already, how do we get feedback of diff | Track test coverage in CI. How? | Develop checklist for reviewers and for PRs | Can we simulate other environments too? Snapshots on third party tool? | metrics : contribution guide, or for reviewers. | React testing? | ensure unit tests for reducers cover all action types | . ",
    "url": "/reference/testing-strategy/#feedback",
    "relUrl": "/reference/testing-strategy/#feedback"
  },"189": {
    "doc": "Project Testing Strategy",
    "title": "Project Testing Strategy",
    "content": "This document describes our approach to testing the software stack. It is intended for developers, or technically oriented users who wish to contribute code to the project. ",
    "url": "/reference/testing-strategy/",
    "relUrl": "/reference/testing-strategy/"
  },"190": {
    "doc": "Variable Naming",
    "title": "Variable Naming",
    "content": " ",
    "url": "/reference/variable-naming/",
    "relUrl": "/reference/variable-naming/"
  },"191": {
    "doc": "Variable Types",
    "title": "Boolean",
    "content": "Represents dichotomous categories with only two possible values (e.g. true/false). Compatible Input Controls: . | Toggle | . Validation Options: Required . ",
    "url": "/reference/variable-types/#boolean",
    "relUrl": "/reference/variable-types/#boolean"
  },"192": {
    "doc": "Variable Types",
    "title": "Categorical",
    "content": "These variables represent nominal categories or characteristics that have no intrinsic ordering or hierarchy (e.g. gender, nationality, etc.). Compatible Input Controls: . | Toggle Button Group | Checkbox Group | . Validation Options: MinSelected, MaxSelected, Required . ",
    "url": "/reference/variable-types/#categorical",
    "relUrl": "/reference/variable-types/#categorical"
  },"193": {
    "doc": "Variable Types",
    "title": "Datetime",
    "content": "These variables represent a point in time (typically a date). Compatible Input Controls: . | Date Picker | Relative Date Picker | . Validation Options: Required . ",
    "url": "/reference/variable-types/#datetime",
    "relUrl": "/reference/variable-types/#datetime"
  },"194": {
    "doc": "Variable Types",
    "title": "Layout",
    "content": "These variables store the x, y coordinates of nodes on the Sociogram normalized to a range of [0, 1]. This variable type has no validation options or input controls, because it cannot be used on a form. ",
    "url": "/reference/variable-types/#layout",
    "relUrl": "/reference/variable-types/#layout"
  },"195": {
    "doc": "Variable Types",
    "title": "Number",
    "content": "These variables represent integer values (e.g. age, height, etc.). Compatible Input Controls: . | Number Input | . Validation Options: MaxValue, MinValue, Required . ",
    "url": "/reference/variable-types/#number",
    "relUrl": "/reference/variable-types/#number"
  },"196": {
    "doc": "Variable Types",
    "title": "Ordinal",
    "content": "These variables represent categories that are ordered hierarchically (e.g. frequency of contact, level of education, etc.). Compatible Input Controls: . | Likert Scale | Radio Group | . Validation Options: Required . ",
    "url": "/reference/variable-types/#ordinal",
    "relUrl": "/reference/variable-types/#ordinal"
  },"197": {
    "doc": "Variable Types",
    "title": "Scalar",
    "content": "These variables represent a normalized value within a scale [0.1] (e.g. perceived pain). Compatible Input Controls: . | Visual Analog Scale | . Validation Options: Required . ",
    "url": "/reference/variable-types/#scalar",
    "relUrl": "/reference/variable-types/#scalar"
  },"198": {
    "doc": "Variable Types",
    "title": "Text",
    "content": "These variables represent text data (e.g. names, qualitative responses, etc.). Compatible Input Controls: . | Text Input | Text Area | . Validation Options: MinLength, MaxLength, Required . ",
    "url": "/reference/variable-types/#text",
    "relUrl": "/reference/variable-types/#text"
  },"199": {
    "doc": "Variable Types",
    "title": "Variable Types",
    "content": "The Network Canvas software supports modeling data using a standard of variety data types. Below you will find these types summarized, along with relevant information about their limitations and features. ",
    "url": "/reference/variable-types/",
    "relUrl": "/reference/variable-types/"
  }
}
